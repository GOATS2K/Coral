/**
 * Generated by @openapi-codegen
 *
 * @version v1
 */
import * as reactQuery from "@tanstack/react-query";
import { type Context, useContext, queryKeyFn } from "./context";
import { deepMerge } from "./utils";
import type * as Fetcher from "./fetcher";
import { fetch } from "./fetcher";
import type * as Schemas from "./schemas";

type QueryFnOptions = {
  signal?: AbortController["signal"];
};

export type GetArtworkQueryParams = {
  /**
   * @format uuid
   */
  albumId?: string;
  size?: Schemas.ArtworkSize;
};

export type GetArtworkError = Fetcher.ErrorWrapper<undefined>;

export type GetArtworkVariables = {
  queryParams?: GetArtworkQueryParams;
} & Context["fetcherOptions"];

export const fetchGetArtwork = (
  variables: GetArtworkVariables,
  signal?: AbortSignal,
) =>
  fetch<undefined, GetArtworkError, undefined, {}, GetArtworkQueryParams, {}>({
    url: "/api/Artwork",
    method: "get",
    ...variables,
    signal,
  });

export function getArtworkQuery(variables: GetArtworkVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function getArtworkQuery(
  variables: GetArtworkVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function getArtworkQuery(
  variables: GetArtworkVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Artwork",
      operationId: "getArtwork",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetArtwork(variables, signal),
  };
}

export const useSuspenseGetArtwork = <TData = undefined,>(
  variables: GetArtworkVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetArtworkError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<undefined, GetArtworkError, TData>({
    ...getArtworkQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetArtwork = <TData = undefined,>(
  variables: GetArtworkVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetArtworkError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<undefined, GetArtworkError, TData>({
    ...getArtworkQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type ArtworkFromIdPathParams = {
  /**
   * @format uuid
   */
  artworkId: string;
};

export type ArtworkFromIdQueryParams = {
  size?: Schemas.ArtworkSize;
};

export type ArtworkFromIdError = Fetcher.ErrorWrapper<undefined>;

export type ArtworkFromIdVariables = {
  pathParams: ArtworkFromIdPathParams;
  queryParams?: ArtworkFromIdQueryParams;
} & Context["fetcherOptions"];

export const fetchArtworkFromId = (
  variables: ArtworkFromIdVariables,
  signal?: AbortSignal,
) =>
  fetch<
    undefined,
    ArtworkFromIdError,
    undefined,
    {},
    ArtworkFromIdQueryParams,
    ArtworkFromIdPathParams
  >({ url: "/api/Artwork/{artworkId}", method: "get", ...variables, signal });

export function artworkFromIdQuery(variables: ArtworkFromIdVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function artworkFromIdQuery(
  variables: ArtworkFromIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function artworkFromIdQuery(
  variables: ArtworkFromIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Artwork/{artworkId}",
      operationId: "artworkFromId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchArtworkFromId(variables, signal),
  };
}

export const useSuspenseArtworkFromId = <TData = undefined,>(
  variables: ArtworkFromIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, ArtworkFromIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<undefined, ArtworkFromIdError, TData>({
    ...artworkFromIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useArtworkFromId = <TData = undefined,>(
  variables: ArtworkFromIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, ArtworkFromIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<undefined, ArtworkFromIdError, TData>({
    ...artworkFromIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetConfigurationError = Fetcher.ErrorWrapper<undefined>;

export type GetConfigurationVariables = Context["fetcherOptions"];

export const fetchGetConfiguration = (
  variables: GetConfigurationVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.ServerConfiguration,
    GetConfigurationError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/Configuration", method: "get", ...variables, signal });

export function getConfigurationQuery(variables: GetConfigurationVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.ServerConfiguration>;
};

export function getConfigurationQuery(
  variables: GetConfigurationVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.ServerConfiguration>)
    | reactQuery.SkipToken;
};

export function getConfigurationQuery(
  variables: GetConfigurationVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Configuration",
      operationId: "getConfiguration",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetConfiguration(variables, signal),
  };
}

export const useSuspenseGetConfiguration = <
  TData = Schemas.ServerConfiguration,
>(
  variables: GetConfigurationVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ServerConfiguration,
      GetConfigurationError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.ServerConfiguration,
    GetConfigurationError,
    TData
  >({
    ...getConfigurationQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetConfiguration = <TData = Schemas.ServerConfiguration,>(
  variables: GetConfigurationVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ServerConfiguration,
      GetConfigurationError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    Schemas.ServerConfiguration,
    GetConfigurationError,
    TData
  >({
    ...getConfigurationQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type UpdateConfigurationError = Fetcher.ErrorWrapper<undefined>;

export type UpdateConfigurationVariables = {
  body: Schemas.ServerConfiguration;
} & Context["fetcherOptions"];

export const fetchUpdateConfiguration = (
  variables: UpdateConfigurationVariables,
  signal?: AbortSignal,
) =>
  fetch<
    undefined,
    UpdateConfigurationError,
    Schemas.ServerConfiguration,
    {},
    {},
    {}
  >({ url: "/api/Configuration", method: "put", ...variables, signal });

export const useUpdateConfiguration = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      UpdateConfigurationError,
      UpdateConfigurationVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    undefined,
    UpdateConfigurationError,
    UpdateConfigurationVariables
  >({
    mutationFn: (variables: UpdateConfigurationVariables) =>
      fetchUpdateConfiguration(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type RunIndexerError = Fetcher.ErrorWrapper<undefined>;

export type RunIndexerVariables = Context["fetcherOptions"];

export const fetchRunIndexer = (
  variables: RunIndexerVariables,
  signal?: AbortSignal,
) =>
  fetch<undefined, RunIndexerError, undefined, {}, {}, {}>({
    url: "/api/Library/scan",
    method: "post",
    ...variables,
    signal,
  });

export const useRunIndexer = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      RunIndexerError,
      RunIndexerVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    undefined,
    RunIndexerError,
    RunIndexerVariables
  >({
    mutationFn: (variables: RunIndexerVariables) =>
      fetchRunIndexer(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type SearchQueryParams = {
  query?: string;
  /**
   * @format int32
   * @default 0
   */
  offset?: number;
  /**
   * @format int32
   * @default 100
   */
  limit?: number;
};

export type SearchError = Fetcher.ErrorWrapper<undefined>;

export type SearchVariables = {
  queryParams?: SearchQueryParams;
} & Context["fetcherOptions"];

export const fetchSearch = (variables: SearchVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.SearchResultPaginatedCustomData,
    SearchError,
    undefined,
    {},
    SearchQueryParams,
    {}
  >({ url: "/api/Library/search", method: "get", ...variables, signal });

export function searchQuery(variables: SearchVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<Schemas.SearchResultPaginatedCustomData>;
};

export function searchQuery(
  variables: SearchVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<Schemas.SearchResultPaginatedCustomData>)
    | reactQuery.SkipToken;
};

export function searchQuery(variables: SearchVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Library/search",
      operationId: "search",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchSearch(variables, signal),
  };
}

export const useSuspenseSearch = <
  TData = Schemas.SearchResultPaginatedCustomData,
>(
  variables: SearchVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SearchResultPaginatedCustomData,
      SearchError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.SearchResultPaginatedCustomData,
    SearchError,
    TData
  >({
    ...searchQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useSearch = <TData = Schemas.SearchResultPaginatedCustomData,>(
  variables: SearchVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SearchResultPaginatedCustomData,
      SearchError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    Schemas.SearchResultPaginatedCustomData,
    SearchError,
    TData
  >({
    ...searchQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type LogPlaybackPathParams = {
  /**
   * @format uuid
   */
  trackId: string;
};

export type LogPlaybackError = Fetcher.ErrorWrapper<undefined>;

export type LogPlaybackVariables = {
  pathParams: LogPlaybackPathParams;
} & Context["fetcherOptions"];

export const fetchLogPlayback = (
  variables: LogPlaybackVariables,
  signal?: AbortSignal,
) =>
  fetch<undefined, LogPlaybackError, undefined, {}, {}, LogPlaybackPathParams>({
    url: "/api/Library/tracks/{trackId}/logPlayback",
    method: "get",
    ...variables,
    signal,
  });

export function logPlaybackQuery(variables: LogPlaybackVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function logPlaybackQuery(
  variables: LogPlaybackVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function logPlaybackQuery(
  variables: LogPlaybackVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Library/tracks/{trackId}/logPlayback",
      operationId: "logPlayback",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchLogPlayback(variables, signal),
  };
}

export const useSuspenseLogPlayback = <TData = undefined,>(
  variables: LogPlaybackVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, LogPlaybackError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<undefined, LogPlaybackError, TData>({
    ...logPlaybackQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useLogPlayback = <TData = undefined,>(
  variables: LogPlaybackVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, LogPlaybackError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<undefined, LogPlaybackError, TData>({
    ...logPlaybackQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type FileFromLibraryPathParams = {
  /**
   * @format uuid
   */
  trackId: string;
};

export type FileFromLibraryError = Fetcher.ErrorWrapper<undefined>;

export type FileFromLibraryVariables = {
  pathParams: FileFromLibraryPathParams;
} & Context["fetcherOptions"];

export const fetchFileFromLibrary = (
  variables: FileFromLibraryVariables,
  signal?: AbortSignal,
) =>
  fetch<
    undefined,
    FileFromLibraryError,
    undefined,
    {},
    {},
    FileFromLibraryPathParams
  >({
    url: "/api/Library/tracks/{trackId}/original",
    method: "get",
    ...variables,
    signal,
  });

export function fileFromLibraryQuery(variables: FileFromLibraryVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function fileFromLibraryQuery(
  variables: FileFromLibraryVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function fileFromLibraryQuery(
  variables: FileFromLibraryVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Library/tracks/{trackId}/original",
      operationId: "fileFromLibrary",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchFileFromLibrary(variables, signal),
  };
}

export const useSuspenseFileFromLibrary = <TData = undefined,>(
  variables: FileFromLibraryVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, FileFromLibraryError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<undefined, FileFromLibraryError, TData>({
    ...fileFromLibraryQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useFileFromLibrary = <TData = undefined,>(
  variables: FileFromLibraryVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, FileFromLibraryError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<undefined, FileFromLibraryError, TData>({
    ...fileFromLibraryQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type TranscodeTrackPathParams = {
  /**
   * @format uuid
   */
  trackId: string;
};

export type TranscodeTrackQueryParams = {
  /**
   * @format int32
   */
  bitrate?: number;
};

export type TranscodeTrackError = Fetcher.ErrorWrapper<undefined>;

export type TranscodeTrackVariables = {
  pathParams: TranscodeTrackPathParams;
  queryParams?: TranscodeTrackQueryParams;
} & Context["fetcherOptions"];

export const fetchTranscodeTrack = (
  variables: TranscodeTrackVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.StreamDto,
    TranscodeTrackError,
    undefined,
    {},
    TranscodeTrackQueryParams,
    TranscodeTrackPathParams
  >({
    url: "/api/Library/tracks/{trackId}/transcode",
    method: "get",
    ...variables,
    signal,
  });

export function transcodeTrackQuery(variables: TranscodeTrackVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.StreamDto>;
};

export function transcodeTrackQuery(
  variables: TranscodeTrackVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.StreamDto>)
    | reactQuery.SkipToken;
};

export function transcodeTrackQuery(
  variables: TranscodeTrackVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Library/tracks/{trackId}/transcode",
      operationId: "transcodeTrack",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchTranscodeTrack(variables, signal),
  };
}

export const useSuspenseTranscodeTrack = <TData = Schemas.StreamDto,>(
  variables: TranscodeTrackVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.StreamDto, TranscodeTrackError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.StreamDto,
    TranscodeTrackError,
    TData
  >({
    ...transcodeTrackQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useTranscodeTrack = <TData = Schemas.StreamDto,>(
  variables: TranscodeTrackVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.StreamDto, TranscodeTrackError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<Schemas.StreamDto, TranscodeTrackError, TData>({
    ...transcodeTrackQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type StreamTrackPathParams = {
  /**
   * @format uuid
   */
  trackId: string;
};

export type StreamTrackError = Fetcher.ErrorWrapper<undefined>;

export type StreamTrackVariables = {
  pathParams: StreamTrackPathParams;
} & Context["fetcherOptions"];

export const fetchStreamTrack = (
  variables: StreamTrackVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.StreamDto,
    StreamTrackError,
    undefined,
    {},
    {},
    StreamTrackPathParams
  >({
    url: "/api/Library/tracks/{trackId}/stream",
    method: "get",
    ...variables,
    signal,
  });

export function streamTrackQuery(variables: StreamTrackVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.StreamDto>;
};

export function streamTrackQuery(
  variables: StreamTrackVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.StreamDto>)
    | reactQuery.SkipToken;
};

export function streamTrackQuery(
  variables: StreamTrackVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Library/tracks/{trackId}/stream",
      operationId: "streamTrack",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchStreamTrack(variables, signal),
  };
}

export const useSuspenseStreamTrack = <TData = Schemas.StreamDto,>(
  variables: StreamTrackVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.StreamDto, StreamTrackError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.StreamDto,
    StreamTrackError,
    TData
  >({
    ...streamTrackQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useStreamTrack = <TData = Schemas.StreamDto,>(
  variables: StreamTrackVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.StreamDto, StreamTrackError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<Schemas.StreamDto, StreamTrackError, TData>({
    ...streamTrackQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type RecommendationsForTrackPathParams = {
  /**
   * @format uuid
   */
  trackId: string;
};

export type RecommendationsForTrackError = Fetcher.ErrorWrapper<undefined>;

export type RecommendationsForTrackResponse = Schemas.SimpleTrackDto[];

export type RecommendationsForTrackVariables = {
  pathParams: RecommendationsForTrackPathParams;
} & Context["fetcherOptions"];

export const fetchRecommendationsForTrack = (
  variables: RecommendationsForTrackVariables,
  signal?: AbortSignal,
) =>
  fetch<
    RecommendationsForTrackResponse,
    RecommendationsForTrackError,
    undefined,
    {},
    {},
    RecommendationsForTrackPathParams
  >({
    url: "/api/Library/tracks/{trackId}/recommendations",
    method: "get",
    ...variables,
    signal,
  });

export function recommendationsForTrackQuery(
  variables: RecommendationsForTrackVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<RecommendationsForTrackResponse>;
};

export function recommendationsForTrackQuery(
  variables: RecommendationsForTrackVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<RecommendationsForTrackResponse>)
    | reactQuery.SkipToken;
};

export function recommendationsForTrackQuery(
  variables: RecommendationsForTrackVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Library/tracks/{trackId}/recommendations",
      operationId: "recommendationsForTrack",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchRecommendationsForTrack(variables, signal),
  };
}

export const useSuspenseRecommendationsForTrack = <
  TData = RecommendationsForTrackResponse,
>(
  variables: RecommendationsForTrackVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      RecommendationsForTrackResponse,
      RecommendationsForTrackError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    RecommendationsForTrackResponse,
    RecommendationsForTrackError,
    TData
  >({
    ...recommendationsForTrackQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useRecommendationsForTrack = <
  TData = RecommendationsForTrackResponse,
>(
  variables: RecommendationsForTrackVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      RecommendationsForTrackResponse,
      RecommendationsForTrackError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    RecommendationsForTrackResponse,
    RecommendationsForTrackError,
    TData
  >({
    ...recommendationsForTrackQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type FavoriteTracksError = Fetcher.ErrorWrapper<undefined>;

export type FavoriteTracksResponse = Schemas.SimpleTrackDto[];

export type FavoriteTracksVariables = Context["fetcherOptions"];

export const fetchFavoriteTracks = (
  variables: FavoriteTracksVariables,
  signal?: AbortSignal,
) =>
  fetch<FavoriteTracksResponse, FavoriteTracksError, undefined, {}, {}, {}>({
    url: "/api/Library/tracks/favorites",
    method: "get",
    ...variables,
    signal,
  });

export function favoriteTracksQuery(variables: FavoriteTracksVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<FavoriteTracksResponse>;
};

export function favoriteTracksQuery(
  variables: FavoriteTracksVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<FavoriteTracksResponse>)
    | reactQuery.SkipToken;
};

export function favoriteTracksQuery(
  variables: FavoriteTracksVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Library/tracks/favorites",
      operationId: "favoriteTracks",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchFavoriteTracks(variables, signal),
  };
}

export const useSuspenseFavoriteTracks = <TData = FavoriteTracksResponse,>(
  variables: FavoriteTracksVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      FavoriteTracksResponse,
      FavoriteTracksError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    FavoriteTracksResponse,
    FavoriteTracksError,
    TData
  >({
    ...favoriteTracksQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useFavoriteTracks = <TData = FavoriteTracksResponse,>(
  variables: FavoriteTracksVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      FavoriteTracksResponse,
      FavoriteTracksError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    FavoriteTracksResponse,
    FavoriteTracksError,
    TData
  >({
    ...favoriteTracksQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type FavoriteAlbumsError = Fetcher.ErrorWrapper<undefined>;

export type FavoriteAlbumsResponse = Schemas.SimpleAlbumDto[];

export type FavoriteAlbumsVariables = Context["fetcherOptions"];

export const fetchFavoriteAlbums = (
  variables: FavoriteAlbumsVariables,
  signal?: AbortSignal,
) =>
  fetch<FavoriteAlbumsResponse, FavoriteAlbumsError, undefined, {}, {}, {}>({
    url: "/albums/favorites",
    method: "get",
    ...variables,
    signal,
  });

export function favoriteAlbumsQuery(variables: FavoriteAlbumsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<FavoriteAlbumsResponse>;
};

export function favoriteAlbumsQuery(
  variables: FavoriteAlbumsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<FavoriteAlbumsResponse>)
    | reactQuery.SkipToken;
};

export function favoriteAlbumsQuery(
  variables: FavoriteAlbumsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/albums/favorites",
      operationId: "favoriteAlbums",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchFavoriteAlbums(variables, signal),
  };
}

export const useSuspenseFavoriteAlbums = <TData = FavoriteAlbumsResponse,>(
  variables: FavoriteAlbumsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      FavoriteAlbumsResponse,
      FavoriteAlbumsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    FavoriteAlbumsResponse,
    FavoriteAlbumsError,
    TData
  >({
    ...favoriteAlbumsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useFavoriteAlbums = <TData = FavoriteAlbumsResponse,>(
  variables: FavoriteAlbumsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      FavoriteAlbumsResponse,
      FavoriteAlbumsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    FavoriteAlbumsResponse,
    FavoriteAlbumsError,
    TData
  >({
    ...favoriteAlbumsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type RecentlyAddedAlbumsError = Fetcher.ErrorWrapper<undefined>;

export type RecentlyAddedAlbumsResponse = Schemas.SimpleAlbumDto[];

export type RecentlyAddedAlbumsVariables = Context["fetcherOptions"];

export const fetchRecentlyAddedAlbums = (
  variables: RecentlyAddedAlbumsVariables,
  signal?: AbortSignal,
) =>
  fetch<
    RecentlyAddedAlbumsResponse,
    RecentlyAddedAlbumsError,
    undefined,
    {},
    {},
    {}
  >({
    url: "/api/Library/albums/recently-added",
    method: "get",
    ...variables,
    signal,
  });

export function recentlyAddedAlbumsQuery(
  variables: RecentlyAddedAlbumsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<RecentlyAddedAlbumsResponse>;
};

export function recentlyAddedAlbumsQuery(
  variables: RecentlyAddedAlbumsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<RecentlyAddedAlbumsResponse>)
    | reactQuery.SkipToken;
};

export function recentlyAddedAlbumsQuery(
  variables: RecentlyAddedAlbumsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Library/albums/recently-added",
      operationId: "recentlyAddedAlbums",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchRecentlyAddedAlbums(variables, signal),
  };
}

export const useSuspenseRecentlyAddedAlbums = <
  TData = RecentlyAddedAlbumsResponse,
>(
  variables: RecentlyAddedAlbumsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      RecentlyAddedAlbumsResponse,
      RecentlyAddedAlbumsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    RecentlyAddedAlbumsResponse,
    RecentlyAddedAlbumsError,
    TData
  >({
    ...recentlyAddedAlbumsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useRecentlyAddedAlbums = <TData = RecentlyAddedAlbumsResponse,>(
  variables: RecentlyAddedAlbumsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      RecentlyAddedAlbumsResponse,
      RecentlyAddedAlbumsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    RecentlyAddedAlbumsResponse,
    RecentlyAddedAlbumsError,
    TData
  >({
    ...recentlyAddedAlbumsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type FavoriteArtistsError = Fetcher.ErrorWrapper<undefined>;

export type FavoriteArtistsResponse = Schemas.SimpleArtistDto[];

export type FavoriteArtistsVariables = Context["fetcherOptions"];

export const fetchFavoriteArtists = (
  variables: FavoriteArtistsVariables,
  signal?: AbortSignal,
) =>
  fetch<FavoriteArtistsResponse, FavoriteArtistsError, undefined, {}, {}, {}>({
    url: "/api/Library/artists/favorites",
    method: "get",
    ...variables,
    signal,
  });

export function favoriteArtistsQuery(variables: FavoriteArtistsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<FavoriteArtistsResponse>;
};

export function favoriteArtistsQuery(
  variables: FavoriteArtistsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<FavoriteArtistsResponse>)
    | reactQuery.SkipToken;
};

export function favoriteArtistsQuery(
  variables: FavoriteArtistsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Library/artists/favorites",
      operationId: "favoriteArtists",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchFavoriteArtists(variables, signal),
  };
}

export const useSuspenseFavoriteArtists = <TData = FavoriteArtistsResponse,>(
  variables: FavoriteArtistsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      FavoriteArtistsResponse,
      FavoriteArtistsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    FavoriteArtistsResponse,
    FavoriteArtistsError,
    TData
  >({
    ...favoriteArtistsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useFavoriteArtists = <TData = FavoriteArtistsResponse,>(
  variables: FavoriteArtistsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      FavoriteArtistsResponse,
      FavoriteArtistsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    FavoriteArtistsResponse,
    FavoriteArtistsError,
    TData
  >({
    ...favoriteArtistsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type FavoriteTrackPathParams = {
  /**
   * @format uuid
   */
  trackId: string;
};

export type FavoriteTrackError = Fetcher.ErrorWrapper<undefined>;

export type FavoriteTrackVariables = {
  pathParams: FavoriteTrackPathParams;
} & Context["fetcherOptions"];

export const fetchFavoriteTrack = (
  variables: FavoriteTrackVariables,
  signal?: AbortSignal,
) =>
  fetch<
    undefined,
    FavoriteTrackError,
    undefined,
    {},
    {},
    FavoriteTrackPathParams
  >({
    url: "/api/Library/tracks/{trackId}/favorite",
    method: "post",
    ...variables,
    signal,
  });

export const useFavoriteTrack = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      FavoriteTrackError,
      FavoriteTrackVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    undefined,
    FavoriteTrackError,
    FavoriteTrackVariables
  >({
    mutationFn: (variables: FavoriteTrackVariables) =>
      fetchFavoriteTrack(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type RemoveFavoriteTrackPathParams = {
  /**
   * @format uuid
   */
  trackId: string;
};

export type RemoveFavoriteTrackError = Fetcher.ErrorWrapper<undefined>;

export type RemoveFavoriteTrackVariables = {
  pathParams: RemoveFavoriteTrackPathParams;
} & Context["fetcherOptions"];

export const fetchRemoveFavoriteTrack = (
  variables: RemoveFavoriteTrackVariables,
  signal?: AbortSignal,
) =>
  fetch<
    undefined,
    RemoveFavoriteTrackError,
    undefined,
    {},
    {},
    RemoveFavoriteTrackPathParams
  >({
    url: "/api/Library/tracks/{trackId}/favorite",
    method: "delete",
    ...variables,
    signal,
  });

export const useRemoveFavoriteTrack = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      RemoveFavoriteTrackError,
      RemoveFavoriteTrackVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    undefined,
    RemoveFavoriteTrackError,
    RemoveFavoriteTrackVariables
  >({
    mutationFn: (variables: RemoveFavoriteTrackVariables) =>
      fetchRemoveFavoriteTrack(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type FavoriteArtistPathParams = {
  /**
   * @format uuid
   */
  artistId: string;
};

export type FavoriteArtistError = Fetcher.ErrorWrapper<undefined>;

export type FavoriteArtistVariables = {
  pathParams: FavoriteArtistPathParams;
} & Context["fetcherOptions"];

export const fetchFavoriteArtist = (
  variables: FavoriteArtistVariables,
  signal?: AbortSignal,
) =>
  fetch<
    undefined,
    FavoriteArtistError,
    undefined,
    {},
    {},
    FavoriteArtistPathParams
  >({
    url: "/api/Library/artists/{artistId}/favorite",
    method: "post",
    ...variables,
    signal,
  });

export const useFavoriteArtist = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      FavoriteArtistError,
      FavoriteArtistVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    undefined,
    FavoriteArtistError,
    FavoriteArtistVariables
  >({
    mutationFn: (variables: FavoriteArtistVariables) =>
      fetchFavoriteArtist(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type RemoveFavoriteArtistPathParams = {
  /**
   * @format uuid
   */
  artistId: string;
};

export type RemoveFavoriteArtistError = Fetcher.ErrorWrapper<undefined>;

export type RemoveFavoriteArtistVariables = {
  pathParams: RemoveFavoriteArtistPathParams;
} & Context["fetcherOptions"];

export const fetchRemoveFavoriteArtist = (
  variables: RemoveFavoriteArtistVariables,
  signal?: AbortSignal,
) =>
  fetch<
    undefined,
    RemoveFavoriteArtistError,
    undefined,
    {},
    {},
    RemoveFavoriteArtistPathParams
  >({
    url: "/api/Library/artists/{artistId}/favorite",
    method: "delete",
    ...variables,
    signal,
  });

export const useRemoveFavoriteArtist = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      RemoveFavoriteArtistError,
      RemoveFavoriteArtistVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    undefined,
    RemoveFavoriteArtistError,
    RemoveFavoriteArtistVariables
  >({
    mutationFn: (variables: RemoveFavoriteArtistVariables) =>
      fetchRemoveFavoriteArtist(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type FavoriteAlbumPathParams = {
  /**
   * @format uuid
   */
  albumId: string;
};

export type FavoriteAlbumError = Fetcher.ErrorWrapper<undefined>;

export type FavoriteAlbumVariables = {
  pathParams: FavoriteAlbumPathParams;
} & Context["fetcherOptions"];

export const fetchFavoriteAlbum = (
  variables: FavoriteAlbumVariables,
  signal?: AbortSignal,
) =>
  fetch<
    undefined,
    FavoriteAlbumError,
    undefined,
    {},
    {},
    FavoriteAlbumPathParams
  >({
    url: "/api/Library/albums/{albumId}/favorite",
    method: "post",
    ...variables,
    signal,
  });

export const useFavoriteAlbum = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      FavoriteAlbumError,
      FavoriteAlbumVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    undefined,
    FavoriteAlbumError,
    FavoriteAlbumVariables
  >({
    mutationFn: (variables: FavoriteAlbumVariables) =>
      fetchFavoriteAlbum(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type RemoveFavoriteAlbumPathParams = {
  /**
   * @format uuid
   */
  albumId: string;
};

export type RemoveFavoriteAlbumError = Fetcher.ErrorWrapper<undefined>;

export type RemoveFavoriteAlbumVariables = {
  pathParams: RemoveFavoriteAlbumPathParams;
} & Context["fetcherOptions"];

export const fetchRemoveFavoriteAlbum = (
  variables: RemoveFavoriteAlbumVariables,
  signal?: AbortSignal,
) =>
  fetch<
    undefined,
    RemoveFavoriteAlbumError,
    undefined,
    {},
    {},
    RemoveFavoriteAlbumPathParams
  >({
    url: "/api/Library/albums/{albumId}/favorite",
    method: "delete",
    ...variables,
    signal,
  });

export const useRemoveFavoriteAlbum = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      RemoveFavoriteAlbumError,
      RemoveFavoriteAlbumVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    undefined,
    RemoveFavoriteAlbumError,
    RemoveFavoriteAlbumVariables
  >({
    mutationFn: (variables: RemoveFavoriteAlbumVariables) =>
      fetchRemoveFavoriteAlbum(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type TracksError = Fetcher.ErrorWrapper<undefined>;

export type TracksResponse = Schemas.TrackDto[];

export type TracksVariables = Context["fetcherOptions"];

export const fetchTracks = (variables: TracksVariables, signal?: AbortSignal) =>
  fetch<TracksResponse, TracksError, undefined, {}, {}, {}>({
    url: "/api/Library/tracks",
    method: "get",
    ...variables,
    signal,
  });

export function tracksQuery(variables: TracksVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<TracksResponse>;
};

export function tracksQuery(
  variables: TracksVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<TracksResponse>)
    | reactQuery.SkipToken;
};

export function tracksQuery(variables: TracksVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Library/tracks",
      operationId: "tracks",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchTracks(variables, signal),
  };
}

export const useSuspenseTracks = <TData = TracksResponse,>(
  variables: TracksVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<TracksResponse, TracksError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<TracksResponse, TracksError, TData>({
    ...tracksQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useTracks = <TData = TracksResponse,>(
  variables: TracksVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<TracksResponse, TracksError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<TracksResponse, TracksError, TData>({
    ...tracksQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type AlbumsError = Fetcher.ErrorWrapper<undefined>;

export type AlbumsResponse = Schemas.SimpleAlbumDto[];

export type AlbumsVariables = Context["fetcherOptions"];

export const fetchAlbums = (variables: AlbumsVariables, signal?: AbortSignal) =>
  fetch<AlbumsResponse, AlbumsError, undefined, {}, {}, {}>({
    url: "/api/Library/albums",
    method: "get",
    ...variables,
    signal,
  });

export function albumsQuery(variables: AlbumsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<AlbumsResponse>;
};

export function albumsQuery(
  variables: AlbumsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<AlbumsResponse>)
    | reactQuery.SkipToken;
};

export function albumsQuery(variables: AlbumsVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Library/albums",
      operationId: "albums",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchAlbums(variables, signal),
  };
}

export const useSuspenseAlbums = <TData = AlbumsResponse,>(
  variables: AlbumsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<AlbumsResponse, AlbumsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<AlbumsResponse, AlbumsError, TData>({
    ...albumsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useAlbums = <TData = AlbumsResponse,>(
  variables: AlbumsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<AlbumsResponse, AlbumsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<AlbumsResponse, AlbumsError, TData>({
    ...albumsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PaginatedAlbumsQueryParams = {
  /**
   * @format int32
   * @default 10
   */
  limit?: number;
  /**
   * @format int32
   * @default 0
   */
  offset?: number;
};

export type PaginatedAlbumsError = Fetcher.ErrorWrapper<undefined>;

export type PaginatedAlbumsVariables = {
  queryParams?: PaginatedAlbumsQueryParams;
} & Context["fetcherOptions"];

export const fetchPaginatedAlbums = (
  variables: PaginatedAlbumsVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.SimpleAlbumDtoPaginatedQuery,
    PaginatedAlbumsError,
    undefined,
    {},
    PaginatedAlbumsQueryParams,
    {}
  >({
    url: "/api/Library/albums/paginated",
    method: "get",
    ...variables,
    signal,
  });

export function paginatedAlbumsQuery(variables: PaginatedAlbumsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<Schemas.SimpleAlbumDtoPaginatedQuery>;
};

export function paginatedAlbumsQuery(
  variables: PaginatedAlbumsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<Schemas.SimpleAlbumDtoPaginatedQuery>)
    | reactQuery.SkipToken;
};

export function paginatedAlbumsQuery(
  variables: PaginatedAlbumsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Library/albums/paginated",
      operationId: "paginatedAlbums",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchPaginatedAlbums(variables, signal),
  };
}

export const useSuspensePaginatedAlbums = <
  TData = Schemas.SimpleAlbumDtoPaginatedQuery,
>(
  variables: PaginatedAlbumsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SimpleAlbumDtoPaginatedQuery,
      PaginatedAlbumsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.SimpleAlbumDtoPaginatedQuery,
    PaginatedAlbumsError,
    TData
  >({
    ...paginatedAlbumsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const usePaginatedAlbums = <
  TData = Schemas.SimpleAlbumDtoPaginatedQuery,
>(
  variables: PaginatedAlbumsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SimpleAlbumDtoPaginatedQuery,
      PaginatedAlbumsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    Schemas.SimpleAlbumDtoPaginatedQuery,
    PaginatedAlbumsError,
    TData
  >({
    ...paginatedAlbumsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PaginatedArtistsQueryParams = {
  /**
   * @format int32
   * @default 10
   */
  limit?: number;
  /**
   * @format int32
   * @default 0
   */
  offset?: number;
};

export type PaginatedArtistsError = Fetcher.ErrorWrapper<undefined>;

export type PaginatedArtistsVariables = {
  queryParams?: PaginatedArtistsQueryParams;
} & Context["fetcherOptions"];

export const fetchPaginatedArtists = (
  variables: PaginatedArtistsVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.SimpleArtistDtoPaginatedQuery,
    PaginatedArtistsError,
    undefined,
    {},
    PaginatedArtistsQueryParams,
    {}
  >({
    url: "/api/Library/artists/paginated",
    method: "get",
    ...variables,
    signal,
  });

export function paginatedArtistsQuery(variables: PaginatedArtistsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<Schemas.SimpleArtistDtoPaginatedQuery>;
};

export function paginatedArtistsQuery(
  variables: PaginatedArtistsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<Schemas.SimpleArtistDtoPaginatedQuery>)
    | reactQuery.SkipToken;
};

export function paginatedArtistsQuery(
  variables: PaginatedArtistsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Library/artists/paginated",
      operationId: "paginatedArtists",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchPaginatedArtists(variables, signal),
  };
}

export const useSuspensePaginatedArtists = <
  TData = Schemas.SimpleArtistDtoPaginatedQuery,
>(
  variables: PaginatedArtistsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SimpleArtistDtoPaginatedQuery,
      PaginatedArtistsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.SimpleArtistDtoPaginatedQuery,
    PaginatedArtistsError,
    TData
  >({
    ...paginatedArtistsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const usePaginatedArtists = <
  TData = Schemas.SimpleArtistDtoPaginatedQuery,
>(
  variables: PaginatedArtistsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SimpleArtistDtoPaginatedQuery,
      PaginatedArtistsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    Schemas.SimpleArtistDtoPaginatedQuery,
    PaginatedArtistsError,
    TData
  >({
    ...paginatedArtistsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type AlbumPathParams = {
  /**
   * @format uuid
   */
  albumId: string;
};

export type AlbumError = Fetcher.ErrorWrapper<undefined>;

export type AlbumVariables = {
  pathParams: AlbumPathParams;
} & Context["fetcherOptions"];

export const fetchAlbum = (variables: AlbumVariables, signal?: AbortSignal) =>
  fetch<Schemas.AlbumDto, AlbumError, undefined, {}, {}, AlbumPathParams>({
    url: "/api/Library/albums/{albumId}",
    method: "get",
    ...variables,
    signal,
  });

export function albumQuery(variables: AlbumVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.AlbumDto>;
};

export function albumQuery(variables: AlbumVariables | reactQuery.SkipToken): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.AlbumDto>)
    | reactQuery.SkipToken;
};

export function albumQuery(variables: AlbumVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Library/albums/{albumId}",
      operationId: "album",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchAlbum(variables, signal),
  };
}

export const useSuspenseAlbum = <TData = Schemas.AlbumDto,>(
  variables: AlbumVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.AlbumDto, AlbumError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<Schemas.AlbumDto, AlbumError, TData>({
    ...albumQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useAlbum = <TData = Schemas.AlbumDto,>(
  variables: AlbumVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.AlbumDto, AlbumError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<Schemas.AlbumDto, AlbumError, TData>({
    ...albumQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type AlbumTracksPathParams = {
  /**
   * @format uuid
   */
  albumId: string;
};

export type AlbumTracksError = Fetcher.ErrorWrapper<undefined>;

export type AlbumTracksResponse = Schemas.SimpleTrackDto[];

export type AlbumTracksVariables = {
  pathParams: AlbumTracksPathParams;
} & Context["fetcherOptions"];

export const fetchAlbumTracks = (
  variables: AlbumTracksVariables,
  signal?: AbortSignal,
) =>
  fetch<
    AlbumTracksResponse,
    AlbumTracksError,
    undefined,
    {},
    {},
    AlbumTracksPathParams
  >({
    url: "/api/Library/albums/{albumId}/tracks",
    method: "get",
    ...variables,
    signal,
  });

export function albumTracksQuery(variables: AlbumTracksVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<AlbumTracksResponse>;
};

export function albumTracksQuery(
  variables: AlbumTracksVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<AlbumTracksResponse>)
    | reactQuery.SkipToken;
};

export function albumTracksQuery(
  variables: AlbumTracksVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Library/albums/{albumId}/tracks",
      operationId: "albumTracks",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchAlbumTracks(variables, signal),
  };
}

export const useSuspenseAlbumTracks = <TData = AlbumTracksResponse,>(
  variables: AlbumTracksVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<AlbumTracksResponse, AlbumTracksError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    AlbumTracksResponse,
    AlbumTracksError,
    TData
  >({
    ...albumTracksQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useAlbumTracks = <TData = AlbumTracksResponse,>(
  variables: AlbumTracksVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<AlbumTracksResponse, AlbumTracksError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<AlbumTracksResponse, AlbumTracksError, TData>({
    ...albumTracksQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type ArtistPathParams = {
  /**
   * @format uuid
   */
  artistId: string;
};

export type ArtistError = Fetcher.ErrorWrapper<undefined>;

export type ArtistVariables = {
  pathParams: ArtistPathParams;
} & Context["fetcherOptions"];

export const fetchArtist = (variables: ArtistVariables, signal?: AbortSignal) =>
  fetch<Schemas.ArtistDto, ArtistError, undefined, {}, {}, ArtistPathParams>({
    url: "/api/Library/artists/{artistId}",
    method: "get",
    ...variables,
    signal,
  });

export function artistQuery(variables: ArtistVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.ArtistDto>;
};

export function artistQuery(
  variables: ArtistVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.ArtistDto>)
    | reactQuery.SkipToken;
};

export function artistQuery(variables: ArtistVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Library/artists/{artistId}",
      operationId: "artist",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchArtist(variables, signal),
  };
}

export const useSuspenseArtist = <TData = Schemas.ArtistDto,>(
  variables: ArtistVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.ArtistDto, ArtistError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<Schemas.ArtistDto, ArtistError, TData>({
    ...artistQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useArtist = <TData = Schemas.ArtistDto,>(
  variables: ArtistVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.ArtistDto, ArtistError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<Schemas.ArtistDto, ArtistError, TData>({
    ...artistQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type DirectoriesInPathQueryParams = {
  path?: string;
};

export type DirectoriesInPathError = Fetcher.ErrorWrapper<undefined>;

export type DirectoriesInPathResponse = string[];

export type DirectoriesInPathVariables = {
  queryParams?: DirectoriesInPathQueryParams;
} & Context["fetcherOptions"];

export const fetchDirectoriesInPath = (
  variables: DirectoriesInPathVariables,
  signal?: AbortSignal,
) =>
  fetch<
    DirectoriesInPathResponse,
    DirectoriesInPathError,
    undefined,
    {},
    DirectoriesInPathQueryParams,
    {}
  >({
    url: "/api/Onboarding/listDirectories",
    method: "get",
    ...variables,
    signal,
  });

export function directoriesInPathQuery(variables: DirectoriesInPathVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<DirectoriesInPathResponse>;
};

export function directoriesInPathQuery(
  variables: DirectoriesInPathVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<DirectoriesInPathResponse>)
    | reactQuery.SkipToken;
};

export function directoriesInPathQuery(
  variables: DirectoriesInPathVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Onboarding/listDirectories",
      operationId: "directoriesInPath",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchDirectoriesInPath(variables, signal),
  };
}

export const useSuspenseDirectoriesInPath = <
  TData = DirectoriesInPathResponse,
>(
  variables: DirectoriesInPathVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      DirectoriesInPathResponse,
      DirectoriesInPathError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    DirectoriesInPathResponse,
    DirectoriesInPathError,
    TData
  >({
    ...directoriesInPathQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useDirectoriesInPath = <TData = DirectoriesInPathResponse,>(
  variables: DirectoriesInPathVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      DirectoriesInPathResponse,
      DirectoriesInPathError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    DirectoriesInPathResponse,
    DirectoriesInPathError,
    TData
  >({
    ...directoriesInPathQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type MusicLibrariesError = Fetcher.ErrorWrapper<undefined>;

export type MusicLibrariesResponse = Schemas.MusicLibraryDto[];

export type MusicLibrariesVariables = Context["fetcherOptions"];

export const fetchMusicLibraries = (
  variables: MusicLibrariesVariables,
  signal?: AbortSignal,
) =>
  fetch<MusicLibrariesResponse, MusicLibrariesError, undefined, {}, {}, {}>({
    url: "/api/Onboarding/musicLibraries",
    method: "get",
    ...variables,
    signal,
  });

export function musicLibrariesQuery(variables: MusicLibrariesVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<MusicLibrariesResponse>;
};

export function musicLibrariesQuery(
  variables: MusicLibrariesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<MusicLibrariesResponse>)
    | reactQuery.SkipToken;
};

export function musicLibrariesQuery(
  variables: MusicLibrariesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Onboarding/musicLibraries",
      operationId: "musicLibraries",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchMusicLibraries(variables, signal),
  };
}

export const useSuspenseMusicLibraries = <TData = MusicLibrariesResponse,>(
  variables: MusicLibrariesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      MusicLibrariesResponse,
      MusicLibrariesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    MusicLibrariesResponse,
    MusicLibrariesError,
    TData
  >({
    ...musicLibrariesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useMusicLibraries = <TData = MusicLibrariesResponse,>(
  variables: MusicLibrariesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      MusicLibrariesResponse,
      MusicLibrariesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    MusicLibrariesResponse,
    MusicLibrariesError,
    TData
  >({
    ...musicLibrariesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type RegisterMusicLibraryQueryParams = {
  path?: string;
};

export type RegisterMusicLibraryError = Fetcher.ErrorWrapper<undefined>;

export type RegisterMusicLibraryVariables = {
  queryParams?: RegisterMusicLibraryQueryParams;
} & Context["fetcherOptions"];

export const fetchRegisterMusicLibrary = (
  variables: RegisterMusicLibraryVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.MusicLibrary,
    RegisterMusicLibraryError,
    undefined,
    {},
    RegisterMusicLibraryQueryParams,
    {}
  >({ url: "/api/Onboarding/register", method: "post", ...variables, signal });

export const useRegisterMusicLibrary = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MusicLibrary,
      RegisterMusicLibraryError,
      RegisterMusicLibraryVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    Schemas.MusicLibrary,
    RegisterMusicLibraryError,
    RegisterMusicLibraryVariables
  >({
    mutationFn: (variables: RegisterMusicLibraryVariables) =>
      fetchRegisterMusicLibrary(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type LoadAllPluginsError = Fetcher.ErrorWrapper<undefined>;

export type LoadAllPluginsVariables = Context["fetcherOptions"];

export const fetchLoadAllPlugins = (
  variables: LoadAllPluginsVariables,
  signal?: AbortSignal,
) =>
  fetch<undefined, LoadAllPluginsError, undefined, {}, {}, {}>({
    url: "/api/Plugin/load",
    method: "get",
    ...variables,
    signal,
  });

export function loadAllPluginsQuery(variables: LoadAllPluginsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function loadAllPluginsQuery(
  variables: LoadAllPluginsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function loadAllPluginsQuery(
  variables: LoadAllPluginsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Plugin/load",
      operationId: "loadAllPlugins",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchLoadAllPlugins(variables, signal),
  };
}

export const useSuspenseLoadAllPlugins = <TData = undefined,>(
  variables: LoadAllPluginsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, LoadAllPluginsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<undefined, LoadAllPluginsError, TData>({
    ...loadAllPluginsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useLoadAllPlugins = <TData = undefined,>(
  variables: LoadAllPluginsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, LoadAllPluginsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<undefined, LoadAllPluginsError, TData>({
    ...loadAllPluginsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type UnloadPluginsError = Fetcher.ErrorWrapper<undefined>;

export type UnloadPluginsVariables = Context["fetcherOptions"];

export const fetchUnloadPlugins = (
  variables: UnloadPluginsVariables,
  signal?: AbortSignal,
) =>
  fetch<undefined, UnloadPluginsError, undefined, {}, {}, {}>({
    url: "/api/Plugin/unload",
    method: "get",
    ...variables,
    signal,
  });

export function unloadPluginsQuery(variables: UnloadPluginsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function unloadPluginsQuery(
  variables: UnloadPluginsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function unloadPluginsQuery(
  variables: UnloadPluginsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Plugin/unload",
      operationId: "unloadPlugins",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchUnloadPlugins(variables, signal),
  };
}

export const useSuspenseUnloadPlugins = <TData = undefined,>(
  variables: UnloadPluginsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, UnloadPluginsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<undefined, UnloadPluginsError, TData>({
    ...unloadPluginsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useUnloadPlugins = <TData = undefined,>(
  variables: UnloadPluginsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, UnloadPluginsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<undefined, UnloadPluginsError, TData>({
    ...unloadPluginsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type QueryOperation =
  | {
      path: "/api/Artwork";
      operationId: "getArtwork";
      variables: GetArtworkVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Artwork/{artworkId}";
      operationId: "artworkFromId";
      variables: ArtworkFromIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Configuration";
      operationId: "getConfiguration";
      variables: GetConfigurationVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Library/search";
      operationId: "search";
      variables: SearchVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Library/tracks/{trackId}/logPlayback";
      operationId: "logPlayback";
      variables: LogPlaybackVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Library/tracks/{trackId}/original";
      operationId: "fileFromLibrary";
      variables: FileFromLibraryVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Library/tracks/{trackId}/transcode";
      operationId: "transcodeTrack";
      variables: TranscodeTrackVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Library/tracks/{trackId}/stream";
      operationId: "streamTrack";
      variables: StreamTrackVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Library/tracks/{trackId}/recommendations";
      operationId: "recommendationsForTrack";
      variables: RecommendationsForTrackVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Library/tracks/favorites";
      operationId: "favoriteTracks";
      variables: FavoriteTracksVariables | reactQuery.SkipToken;
    }
  | {
      path: "/albums/favorites";
      operationId: "favoriteAlbums";
      variables: FavoriteAlbumsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Library/albums/recently-added";
      operationId: "recentlyAddedAlbums";
      variables: RecentlyAddedAlbumsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Library/artists/favorites";
      operationId: "favoriteArtists";
      variables: FavoriteArtistsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Library/tracks";
      operationId: "tracks";
      variables: TracksVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Library/albums";
      operationId: "albums";
      variables: AlbumsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Library/albums/paginated";
      operationId: "paginatedAlbums";
      variables: PaginatedAlbumsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Library/artists/paginated";
      operationId: "paginatedArtists";
      variables: PaginatedArtistsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Library/albums/{albumId}";
      operationId: "album";
      variables: AlbumVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Library/albums/{albumId}/tracks";
      operationId: "albumTracks";
      variables: AlbumTracksVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Library/artists/{artistId}";
      operationId: "artist";
      variables: ArtistVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Onboarding/listDirectories";
      operationId: "directoriesInPath";
      variables: DirectoriesInPathVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Onboarding/musicLibraries";
      operationId: "musicLibraries";
      variables: MusicLibrariesVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Plugin/load";
      operationId: "loadAllPlugins";
      variables: LoadAllPluginsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Plugin/unload";
      operationId: "unloadPlugins";
      variables: UnloadPluginsVariables | reactQuery.SkipToken;
    };
