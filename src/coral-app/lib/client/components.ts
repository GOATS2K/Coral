/**
 * Generated by @openapi-codegen
 *
 * @version v1
 */
import * as reactQuery from "@tanstack/react-query";
import { type Context, useContext, queryKeyFn } from "./context";
import { deepMerge } from "./utils";
import type * as Fetcher from "./fetcher";
import { fetch } from "./fetcher";
import type * as Schemas from "./schemas";

type QueryFnOptions = {
  signal?: AbortController["signal"];
};

export type AlbumsQueryParams = {
  /**
   * @format int32
   * @default 10
   */
  limit?: number;
  /**
   * @format int32
   * @default 0
   */
  offset?: number;
};

export type AlbumsError = Fetcher.ErrorWrapper<undefined>;

export type AlbumsVariables = {
  queryParams?: AlbumsQueryParams;
} & Context["fetcherOptions"];

export const fetchAlbums = (variables: AlbumsVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.SimpleAlbumDtoPaginatedQuery,
    AlbumsError,
    undefined,
    {},
    AlbumsQueryParams,
    {}
  >({ url: "/api/albums", method: "get", ...variables, signal });

export function albumsQuery(variables: AlbumsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<Schemas.SimpleAlbumDtoPaginatedQuery>;
};

export function albumsQuery(
  variables: AlbumsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<Schemas.SimpleAlbumDtoPaginatedQuery>)
    | reactQuery.SkipToken;
};

export function albumsQuery(variables: AlbumsVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: "/api/albums",
      operationId: "albums",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchAlbums(variables, signal),
  };
}

export const useSuspenseAlbums = <
  TData = Schemas.SimpleAlbumDtoPaginatedQuery,
>(
  variables: AlbumsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SimpleAlbumDtoPaginatedQuery,
      AlbumsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.SimpleAlbumDtoPaginatedQuery,
    AlbumsError,
    TData
  >({
    ...albumsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useAlbums = <TData = Schemas.SimpleAlbumDtoPaginatedQuery,>(
  variables: AlbumsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SimpleAlbumDtoPaginatedQuery,
      AlbumsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    Schemas.SimpleAlbumDtoPaginatedQuery,
    AlbumsError,
    TData
  >({
    ...albumsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type AllAlbumsError = Fetcher.ErrorWrapper<undefined>;

export type AllAlbumsResponse = Schemas.SimpleAlbumDto[];

export type AllAlbumsVariables = Context["fetcherOptions"];

export const fetchAllAlbums = (
  variables: AllAlbumsVariables,
  signal?: AbortSignal,
) =>
  fetch<AllAlbumsResponse, AllAlbumsError, undefined, {}, {}, {}>({
    url: "/api/albums/all",
    method: "get",
    ...variables,
    signal,
  });

export function allAlbumsQuery(variables: AllAlbumsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<AllAlbumsResponse>;
};

export function allAlbumsQuery(
  variables: AllAlbumsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<AllAlbumsResponse>)
    | reactQuery.SkipToken;
};

export function allAlbumsQuery(
  variables: AllAlbumsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/albums/all",
      operationId: "allAlbums",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchAllAlbums(variables, signal),
  };
}

export const useSuspenseAllAlbums = <TData = AllAlbumsResponse,>(
  variables: AllAlbumsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<AllAlbumsResponse, AllAlbumsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<AllAlbumsResponse, AllAlbumsError, TData>({
    ...allAlbumsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useAllAlbums = <TData = AllAlbumsResponse,>(
  variables: AllAlbumsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<AllAlbumsResponse, AllAlbumsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<AllAlbumsResponse, AllAlbumsError, TData>({
    ...allAlbumsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type RecentlyAddedAlbumsError = Fetcher.ErrorWrapper<undefined>;

export type RecentlyAddedAlbumsResponse = Schemas.SimpleAlbumDto[];

export type RecentlyAddedAlbumsVariables = Context["fetcherOptions"];

export const fetchRecentlyAddedAlbums = (
  variables: RecentlyAddedAlbumsVariables,
  signal?: AbortSignal,
) =>
  fetch<
    RecentlyAddedAlbumsResponse,
    RecentlyAddedAlbumsError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/albums/recently-added", method: "get", ...variables, signal });

export function recentlyAddedAlbumsQuery(
  variables: RecentlyAddedAlbumsVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<RecentlyAddedAlbumsResponse>;
};

export function recentlyAddedAlbumsQuery(
  variables: RecentlyAddedAlbumsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<RecentlyAddedAlbumsResponse>)
    | reactQuery.SkipToken;
};

export function recentlyAddedAlbumsQuery(
  variables: RecentlyAddedAlbumsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/albums/recently-added",
      operationId: "recentlyAddedAlbums",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchRecentlyAddedAlbums(variables, signal),
  };
}

export const useSuspenseRecentlyAddedAlbums = <
  TData = RecentlyAddedAlbumsResponse,
>(
  variables: RecentlyAddedAlbumsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      RecentlyAddedAlbumsResponse,
      RecentlyAddedAlbumsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    RecentlyAddedAlbumsResponse,
    RecentlyAddedAlbumsError,
    TData
  >({
    ...recentlyAddedAlbumsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useRecentlyAddedAlbums = <TData = RecentlyAddedAlbumsResponse,>(
  variables: RecentlyAddedAlbumsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      RecentlyAddedAlbumsResponse,
      RecentlyAddedAlbumsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    RecentlyAddedAlbumsResponse,
    RecentlyAddedAlbumsError,
    TData
  >({
    ...recentlyAddedAlbumsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type AlbumPathParams = {
  /**
   * @format uuid
   */
  albumId: string;
};

export type AlbumError = Fetcher.ErrorWrapper<undefined>;

export type AlbumVariables = {
  pathParams: AlbumPathParams;
} & Context["fetcherOptions"];

export const fetchAlbum = (variables: AlbumVariables, signal?: AbortSignal) =>
  fetch<Schemas.AlbumDto, AlbumError, undefined, {}, {}, AlbumPathParams>({
    url: "/api/albums/{albumId}",
    method: "get",
    ...variables,
    signal,
  });

export function albumQuery(variables: AlbumVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.AlbumDto>;
};

export function albumQuery(variables: AlbumVariables | reactQuery.SkipToken): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.AlbumDto>)
    | reactQuery.SkipToken;
};

export function albumQuery(variables: AlbumVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: "/api/albums/{albumId}",
      operationId: "album",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchAlbum(variables, signal),
  };
}

export const useSuspenseAlbum = <TData = Schemas.AlbumDto,>(
  variables: AlbumVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.AlbumDto, AlbumError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<Schemas.AlbumDto, AlbumError, TData>({
    ...albumQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useAlbum = <TData = Schemas.AlbumDto,>(
  variables: AlbumVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.AlbumDto, AlbumError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<Schemas.AlbumDto, AlbumError, TData>({
    ...albumQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type AlbumTracksPathParams = {
  /**
   * @format uuid
   */
  albumId: string;
};

export type AlbumTracksError = Fetcher.ErrorWrapper<undefined>;

export type AlbumTracksResponse = Schemas.SimpleTrackDto[];

export type AlbumTracksVariables = {
  pathParams: AlbumTracksPathParams;
} & Context["fetcherOptions"];

export const fetchAlbumTracks = (
  variables: AlbumTracksVariables,
  signal?: AbortSignal,
) =>
  fetch<
    AlbumTracksResponse,
    AlbumTracksError,
    undefined,
    {},
    {},
    AlbumTracksPathParams
  >({
    url: "/api/albums/{albumId}/tracks",
    method: "get",
    ...variables,
    signal,
  });

export function albumTracksQuery(variables: AlbumTracksVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<AlbumTracksResponse>;
};

export function albumTracksQuery(
  variables: AlbumTracksVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<AlbumTracksResponse>)
    | reactQuery.SkipToken;
};

export function albumTracksQuery(
  variables: AlbumTracksVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/albums/{albumId}/tracks",
      operationId: "albumTracks",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchAlbumTracks(variables, signal),
  };
}

export const useSuspenseAlbumTracks = <TData = AlbumTracksResponse,>(
  variables: AlbumTracksVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<AlbumTracksResponse, AlbumTracksError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    AlbumTracksResponse,
    AlbumTracksError,
    TData
  >({
    ...albumTracksQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useAlbumTracks = <TData = AlbumTracksResponse,>(
  variables: AlbumTracksVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<AlbumTracksResponse, AlbumTracksError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<AlbumTracksResponse, AlbumTracksError, TData>({
    ...albumTracksQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type RecommendationsForAlbumPathParams = {
  /**
   * @format uuid
   */
  albumId: string;
};

export type RecommendationsForAlbumError = Fetcher.ErrorWrapper<undefined>;

export type RecommendationsForAlbumResponse = Schemas.AlbumRecommendationDto[];

export type RecommendationsForAlbumVariables = {
  pathParams: RecommendationsForAlbumPathParams;
} & Context["fetcherOptions"];

export const fetchRecommendationsForAlbum = (
  variables: RecommendationsForAlbumVariables,
  signal?: AbortSignal,
) =>
  fetch<
    RecommendationsForAlbumResponse,
    RecommendationsForAlbumError,
    undefined,
    {},
    {},
    RecommendationsForAlbumPathParams
  >({
    url: "/api/albums/{albumId}/recommendations",
    method: "get",
    ...variables,
    signal,
  });

export function recommendationsForAlbumQuery(
  variables: RecommendationsForAlbumVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<RecommendationsForAlbumResponse>;
};

export function recommendationsForAlbumQuery(
  variables: RecommendationsForAlbumVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<RecommendationsForAlbumResponse>)
    | reactQuery.SkipToken;
};

export function recommendationsForAlbumQuery(
  variables: RecommendationsForAlbumVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/albums/{albumId}/recommendations",
      operationId: "recommendationsForAlbum",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchRecommendationsForAlbum(variables, signal),
  };
}

export const useSuspenseRecommendationsForAlbum = <
  TData = RecommendationsForAlbumResponse,
>(
  variables: RecommendationsForAlbumVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      RecommendationsForAlbumResponse,
      RecommendationsForAlbumError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    RecommendationsForAlbumResponse,
    RecommendationsForAlbumError,
    TData
  >({
    ...recommendationsForAlbumQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useRecommendationsForAlbum = <
  TData = RecommendationsForAlbumResponse,
>(
  variables: RecommendationsForAlbumVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      RecommendationsForAlbumResponse,
      RecommendationsForAlbumError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    RecommendationsForAlbumResponse,
    RecommendationsForAlbumError,
    TData
  >({
    ...recommendationsForAlbumQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type ArtistsQueryParams = {
  /**
   * @format int32
   * @default 10
   */
  limit?: number;
  /**
   * @format int32
   * @default 0
   */
  offset?: number;
};

export type ArtistsError = Fetcher.ErrorWrapper<undefined>;

export type ArtistsVariables = {
  queryParams?: ArtistsQueryParams;
} & Context["fetcherOptions"];

export const fetchArtists = (
  variables: ArtistsVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.SimpleArtistDtoPaginatedQuery,
    ArtistsError,
    undefined,
    {},
    ArtistsQueryParams,
    {}
  >({ url: "/api/artists", method: "get", ...variables, signal });

export function artistsQuery(variables: ArtistsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<Schemas.SimpleArtistDtoPaginatedQuery>;
};

export function artistsQuery(
  variables: ArtistsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<Schemas.SimpleArtistDtoPaginatedQuery>)
    | reactQuery.SkipToken;
};

export function artistsQuery(
  variables: ArtistsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/artists",
      operationId: "artists",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchArtists(variables, signal),
  };
}

export const useSuspenseArtists = <
  TData = Schemas.SimpleArtistDtoPaginatedQuery,
>(
  variables: ArtistsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SimpleArtistDtoPaginatedQuery,
      ArtistsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.SimpleArtistDtoPaginatedQuery,
    ArtistsError,
    TData
  >({
    ...artistsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useArtists = <TData = Schemas.SimpleArtistDtoPaginatedQuery,>(
  variables: ArtistsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SimpleArtistDtoPaginatedQuery,
      ArtistsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    Schemas.SimpleArtistDtoPaginatedQuery,
    ArtistsError,
    TData
  >({
    ...artistsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type ArtistPathParams = {
  /**
   * @format uuid
   */
  artistId: string;
};

export type ArtistError = Fetcher.ErrorWrapper<undefined>;

export type ArtistVariables = {
  pathParams: ArtistPathParams;
} & Context["fetcherOptions"];

export const fetchArtist = (variables: ArtistVariables, signal?: AbortSignal) =>
  fetch<Schemas.ArtistDto, ArtistError, undefined, {}, {}, ArtistPathParams>({
    url: "/api/artists/{artistId}",
    method: "get",
    ...variables,
    signal,
  });

export function artistQuery(variables: ArtistVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.ArtistDto>;
};

export function artistQuery(
  variables: ArtistVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.ArtistDto>)
    | reactQuery.SkipToken;
};

export function artistQuery(variables: ArtistVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: "/api/artists/{artistId}",
      operationId: "artist",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchArtist(variables, signal),
  };
}

export const useSuspenseArtist = <TData = Schemas.ArtistDto,>(
  variables: ArtistVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.ArtistDto, ArtistError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<Schemas.ArtistDto, ArtistError, TData>({
    ...artistQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useArtist = <TData = Schemas.ArtistDto,>(
  variables: ArtistVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.ArtistDto, ArtistError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<Schemas.ArtistDto, ArtistError, TData>({
    ...artistQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetArtworkQueryParams = {
  /**
   * @format uuid
   */
  albumId?: string;
  size?: Schemas.ArtworkSize;
};

export type GetArtworkError = Fetcher.ErrorWrapper<undefined>;

export type GetArtworkVariables = {
  queryParams?: GetArtworkQueryParams;
} & Context["fetcherOptions"];

export const fetchGetArtwork = (
  variables: GetArtworkVariables,
  signal?: AbortSignal,
) =>
  fetch<undefined, GetArtworkError, undefined, {}, GetArtworkQueryParams, {}>({
    url: "/api/Artwork",
    method: "get",
    ...variables,
    signal,
  });

export function getArtworkQuery(variables: GetArtworkVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function getArtworkQuery(
  variables: GetArtworkVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function getArtworkQuery(
  variables: GetArtworkVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Artwork",
      operationId: "getArtwork",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetArtwork(variables, signal),
  };
}

export const useSuspenseGetArtwork = <TData = undefined,>(
  variables: GetArtworkVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetArtworkError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<undefined, GetArtworkError, TData>({
    ...getArtworkQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetArtwork = <TData = undefined,>(
  variables: GetArtworkVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, GetArtworkError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<undefined, GetArtworkError, TData>({
    ...getArtworkQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type ArtworkFromIdPathParams = {
  /**
   * @format uuid
   */
  artworkId: string;
};

export type ArtworkFromIdQueryParams = {
  size?: Schemas.ArtworkSize;
};

export type ArtworkFromIdError = Fetcher.ErrorWrapper<undefined>;

export type ArtworkFromIdVariables = {
  pathParams: ArtworkFromIdPathParams;
  queryParams?: ArtworkFromIdQueryParams;
} & Context["fetcherOptions"];

export const fetchArtworkFromId = (
  variables: ArtworkFromIdVariables,
  signal?: AbortSignal,
) =>
  fetch<
    undefined,
    ArtworkFromIdError,
    undefined,
    {},
    ArtworkFromIdQueryParams,
    ArtworkFromIdPathParams
  >({ url: "/api/Artwork/{artworkId}", method: "get", ...variables, signal });

export function artworkFromIdQuery(variables: ArtworkFromIdVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function artworkFromIdQuery(
  variables: ArtworkFromIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function artworkFromIdQuery(
  variables: ArtworkFromIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Artwork/{artworkId}",
      operationId: "artworkFromId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchArtworkFromId(variables, signal),
  };
}

export const useSuspenseArtworkFromId = <TData = undefined,>(
  variables: ArtworkFromIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, ArtworkFromIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<undefined, ArtworkFromIdError, TData>({
    ...artworkFromIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useArtworkFromId = <TData = undefined,>(
  variables: ArtworkFromIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, ArtworkFromIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<undefined, ArtworkFromIdError, TData>({
    ...artworkFromIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetStatusError = Fetcher.ErrorWrapper<undefined>;

export type GetStatusVariables = Context["fetcherOptions"];

export const fetchGetStatus = (
  variables: GetStatusVariables,
  signal?: AbortSignal,
) =>
  fetch<Schemas.AuthStatusResponse, GetStatusError, undefined, {}, {}, {}>({
    url: "/api/Auth/status",
    method: "get",
    ...variables,
    signal,
  });

export function getStatusQuery(variables: GetStatusVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.AuthStatusResponse>;
};

export function getStatusQuery(
  variables: GetStatusVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.AuthStatusResponse>)
    | reactQuery.SkipToken;
};

export function getStatusQuery(
  variables: GetStatusVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Auth/status",
      operationId: "getStatus",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetStatus(variables, signal),
  };
}

export const useSuspenseGetStatus = <TData = Schemas.AuthStatusResponse,>(
  variables: GetStatusVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.AuthStatusResponse,
      GetStatusError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.AuthStatusResponse,
    GetStatusError,
    TData
  >({
    ...getStatusQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetStatus = <TData = Schemas.AuthStatusResponse,>(
  variables: GetStatusVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.AuthStatusResponse,
      GetStatusError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<Schemas.AuthStatusResponse, GetStatusError, TData>(
    {
      ...getStatusQuery(
        variables === reactQuery.skipToken
          ? variables
          : deepMerge(fetcherOptions, variables),
      ),
      ...options,
      ...queryOptions,
    },
  );
};

export type RegisterError = Fetcher.ErrorWrapper<undefined>;

export type RegisterVariables = {
  body: Schemas.RegisterRequest;
} & Context["fetcherOptions"];

export const fetchRegister = (
  variables: RegisterVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.LoginResponse,
    RegisterError,
    Schemas.RegisterRequest,
    {},
    {},
    {}
  >({ url: "/api/Auth/register", method: "post", ...variables, signal });

export const useRegister = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.LoginResponse,
      RegisterError,
      RegisterVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    Schemas.LoginResponse,
    RegisterError,
    RegisterVariables
  >({
    mutationFn: (variables: RegisterVariables) =>
      fetchRegister(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type LoginError = Fetcher.ErrorWrapper<undefined>;

export type LoginVariables = {
  body: Schemas.LoginRequest;
} & Context["fetcherOptions"];

export const fetchLogin = (variables: LoginVariables, signal?: AbortSignal) =>
  fetch<Schemas.LoginResponse, LoginError, Schemas.LoginRequest, {}, {}, {}>({
    url: "/api/Auth/login",
    method: "post",
    ...variables,
    signal,
  });

export const useLogin = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.LoginResponse,
      LoginError,
      LoginVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    Schemas.LoginResponse,
    LoginError,
    LoginVariables
  >({
    mutationFn: (variables: LoginVariables) =>
      fetchLogin(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type LogoutError = Fetcher.ErrorWrapper<undefined>;

export type LogoutVariables = Context["fetcherOptions"];

export const fetchLogout = (variables: LogoutVariables, signal?: AbortSignal) =>
  fetch<undefined, LogoutError, undefined, {}, {}, {}>({
    url: "/api/Auth/logout",
    method: "post",
    ...variables,
    signal,
  });

export const useLogout = (
  options?: Omit<
    reactQuery.UseMutationOptions<undefined, LogoutError, LogoutVariables>,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<undefined, LogoutError, LogoutVariables>({
    mutationFn: (variables: LogoutVariables) =>
      fetchLogout(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetCurrentUserError = Fetcher.ErrorWrapper<undefined>;

export type GetCurrentUserVariables = Context["fetcherOptions"];

export const fetchGetCurrentUser = (
  variables: GetCurrentUserVariables,
  signal?: AbortSignal,
) =>
  fetch<Schemas.UserDto, GetCurrentUserError, undefined, {}, {}, {}>({
    url: "/api/Auth/me",
    method: "get",
    ...variables,
    signal,
  });

export function getCurrentUserQuery(variables: GetCurrentUserVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.UserDto>;
};

export function getCurrentUserQuery(
  variables: GetCurrentUserVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.UserDto>)
    | reactQuery.SkipToken;
};

export function getCurrentUserQuery(
  variables: GetCurrentUserVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Auth/me",
      operationId: "getCurrentUser",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetCurrentUser(variables, signal),
  };
}

export const useSuspenseGetCurrentUser = <TData = Schemas.UserDto,>(
  variables: GetCurrentUserVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.UserDto, GetCurrentUserError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.UserDto,
    GetCurrentUserError,
    TData
  >({
    ...getCurrentUserQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetCurrentUser = <TData = Schemas.UserDto,>(
  variables: GetCurrentUserVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.UserDto, GetCurrentUserError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<Schemas.UserDto, GetCurrentUserError, TData>({
    ...getCurrentUserQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type ChangePasswordError = Fetcher.ErrorWrapper<undefined>;

export type ChangePasswordVariables = {
  body: Schemas.ChangePasswordRequest;
} & Context["fetcherOptions"];

export const fetchChangePassword = (
  variables: ChangePasswordVariables,
  signal?: AbortSignal,
) =>
  fetch<
    undefined,
    ChangePasswordError,
    Schemas.ChangePasswordRequest,
    {},
    {},
    {}
  >({ url: "/api/Auth/changePassword", method: "post", ...variables, signal });

export const useChangePassword = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      ChangePasswordError,
      ChangePasswordVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    undefined,
    ChangePasswordError,
    ChangePasswordVariables
  >({
    mutationFn: (variables: ChangePasswordVariables) =>
      fetchChangePassword(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetConfigurationError = Fetcher.ErrorWrapper<undefined>;

export type GetConfigurationVariables = Context["fetcherOptions"];

export const fetchGetConfiguration = (
  variables: GetConfigurationVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.ServerConfiguration,
    GetConfigurationError,
    undefined,
    {},
    {},
    {}
  >({ url: "/api/Configuration", method: "get", ...variables, signal });

export function getConfigurationQuery(variables: GetConfigurationVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.ServerConfiguration>;
};

export function getConfigurationQuery(
  variables: GetConfigurationVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.ServerConfiguration>)
    | reactQuery.SkipToken;
};

export function getConfigurationQuery(
  variables: GetConfigurationVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Configuration",
      operationId: "getConfiguration",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetConfiguration(variables, signal),
  };
}

export const useSuspenseGetConfiguration = <
  TData = Schemas.ServerConfiguration,
>(
  variables: GetConfigurationVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ServerConfiguration,
      GetConfigurationError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.ServerConfiguration,
    GetConfigurationError,
    TData
  >({
    ...getConfigurationQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetConfiguration = <TData = Schemas.ServerConfiguration,>(
  variables: GetConfigurationVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ServerConfiguration,
      GetConfigurationError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    Schemas.ServerConfiguration,
    GetConfigurationError,
    TData
  >({
    ...getConfigurationQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type UpdateConfigurationError = Fetcher.ErrorWrapper<undefined>;

export type UpdateConfigurationVariables = {
  body: Schemas.ServerConfiguration;
} & Context["fetcherOptions"];

export const fetchUpdateConfiguration = (
  variables: UpdateConfigurationVariables,
  signal?: AbortSignal,
) =>
  fetch<
    undefined,
    UpdateConfigurationError,
    Schemas.ServerConfiguration,
    {},
    {},
    {}
  >({ url: "/api/Configuration", method: "put", ...variables, signal });

export const useUpdateConfiguration = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      UpdateConfigurationError,
      UpdateConfigurationVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    undefined,
    UpdateConfigurationError,
    UpdateConfigurationVariables
  >({
    mutationFn: (variables: UpdateConfigurationVariables) =>
      fetchUpdateConfiguration(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetDevicesError = Fetcher.ErrorWrapper<undefined>;

export type GetDevicesResponse = Schemas.DeviceDto[];

export type GetDevicesVariables = Context["fetcherOptions"];

export const fetchGetDevices = (
  variables: GetDevicesVariables,
  signal?: AbortSignal,
) =>
  fetch<GetDevicesResponse, GetDevicesError, undefined, {}, {}, {}>({
    url: "/api/Devices",
    method: "get",
    ...variables,
    signal,
  });

export function getDevicesQuery(variables: GetDevicesVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetDevicesResponse>;
};

export function getDevicesQuery(
  variables: GetDevicesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetDevicesResponse>)
    | reactQuery.SkipToken;
};

export function getDevicesQuery(
  variables: GetDevicesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Devices",
      operationId: "getDevices",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetDevices(variables, signal),
  };
}

export const useSuspenseGetDevices = <TData = GetDevicesResponse,>(
  variables: GetDevicesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<GetDevicesResponse, GetDevicesError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    GetDevicesResponse,
    GetDevicesError,
    TData
  >({
    ...getDevicesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetDevices = <TData = GetDevicesResponse,>(
  variables: GetDevicesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<GetDevicesResponse, GetDevicesError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<GetDevicesResponse, GetDevicesError, TData>({
    ...getDevicesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type DeleteDevicePathParams = {
  /**
   * @format uuid
   */
  id: string;
};

export type DeleteDeviceError = Fetcher.ErrorWrapper<undefined>;

export type DeleteDeviceVariables = {
  pathParams: DeleteDevicePathParams;
} & Context["fetcherOptions"];

export const fetchDeleteDevice = (
  variables: DeleteDeviceVariables,
  signal?: AbortSignal,
) =>
  fetch<
    undefined,
    DeleteDeviceError,
    undefined,
    {},
    {},
    DeleteDevicePathParams
  >({ url: "/api/Devices/{id}", method: "delete", ...variables, signal });

export const useDeleteDevice = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      DeleteDeviceError,
      DeleteDeviceVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    undefined,
    DeleteDeviceError,
    DeleteDeviceVariables
  >({
    mutationFn: (variables: DeleteDeviceVariables) =>
      fetchDeleteDevice(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type FavoriteTracksError = Fetcher.ErrorWrapper<undefined>;

export type FavoriteTracksVariables = Context["fetcherOptions"];

export const fetchFavoriteTracks = (
  variables: FavoriteTracksVariables,
  signal?: AbortSignal,
) =>
  fetch<Schemas.PlaylistDto, FavoriteTracksError, undefined, {}, {}, {}>({
    url: "/api/favorites/tracks",
    method: "get",
    ...variables,
    signal,
  });

export function favoriteTracksQuery(variables: FavoriteTracksVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.PlaylistDto>;
};

export function favoriteTracksQuery(
  variables: FavoriteTracksVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.PlaylistDto>)
    | reactQuery.SkipToken;
};

export function favoriteTracksQuery(
  variables: FavoriteTracksVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/favorites/tracks",
      operationId: "favoriteTracks",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchFavoriteTracks(variables, signal),
  };
}

export const useSuspenseFavoriteTracks = <TData = Schemas.PlaylistDto,>(
  variables: FavoriteTracksVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.PlaylistDto, FavoriteTracksError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.PlaylistDto,
    FavoriteTracksError,
    TData
  >({
    ...favoriteTracksQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useFavoriteTracks = <TData = Schemas.PlaylistDto,>(
  variables: FavoriteTracksVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.PlaylistDto, FavoriteTracksError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<Schemas.PlaylistDto, FavoriteTracksError, TData>({
    ...favoriteTracksQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type FavoriteTrackPathParams = {
  /**
   * @format uuid
   */
  trackId: string;
};

export type FavoriteTrackError = Fetcher.ErrorWrapper<undefined>;

export type FavoriteTrackVariables = {
  pathParams: FavoriteTrackPathParams;
} & Context["fetcherOptions"];

export const fetchFavoriteTrack = (
  variables: FavoriteTrackVariables,
  signal?: AbortSignal,
) =>
  fetch<
    undefined,
    FavoriteTrackError,
    undefined,
    {},
    {},
    FavoriteTrackPathParams
  >({
    url: "/api/favorites/tracks/{trackId}",
    method: "post",
    ...variables,
    signal,
  });

export const useFavoriteTrack = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      FavoriteTrackError,
      FavoriteTrackVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    undefined,
    FavoriteTrackError,
    FavoriteTrackVariables
  >({
    mutationFn: (variables: FavoriteTrackVariables) =>
      fetchFavoriteTrack(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type RemoveFavoriteTrackPathParams = {
  /**
   * @format uuid
   */
  trackId: string;
};

export type RemoveFavoriteTrackError = Fetcher.ErrorWrapper<undefined>;

export type RemoveFavoriteTrackVariables = {
  pathParams: RemoveFavoriteTrackPathParams;
} & Context["fetcherOptions"];

export const fetchRemoveFavoriteTrack = (
  variables: RemoveFavoriteTrackVariables,
  signal?: AbortSignal,
) =>
  fetch<
    undefined,
    RemoveFavoriteTrackError,
    undefined,
    {},
    {},
    RemoveFavoriteTrackPathParams
  >({
    url: "/api/favorites/tracks/{trackId}",
    method: "delete",
    ...variables,
    signal,
  });

export const useRemoveFavoriteTrack = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      RemoveFavoriteTrackError,
      RemoveFavoriteTrackVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    undefined,
    RemoveFavoriteTrackError,
    RemoveFavoriteTrackVariables
  >({
    mutationFn: (variables: RemoveFavoriteTrackVariables) =>
      fetchRemoveFavoriteTrack(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type ReorderFavoriteTrackPathParams = {
  /**
   * @format uuid
   */
  playlistTrackId: string;
};

export type ReorderFavoriteTrackError = Fetcher.ErrorWrapper<undefined>;

export type ReorderFavoriteTrackVariables = {
  body?: number;
  pathParams: ReorderFavoriteTrackPathParams;
} & Context["fetcherOptions"];

export const fetchReorderFavoriteTrack = (
  variables: ReorderFavoriteTrackVariables,
  signal?: AbortSignal,
) =>
  fetch<
    undefined,
    ReorderFavoriteTrackError,
    number,
    {},
    {},
    ReorderFavoriteTrackPathParams
  >({
    url: "/api/favorites/tracks/{playlistTrackId}/reorder",
    method: "put",
    ...variables,
    signal,
  });

export const useReorderFavoriteTrack = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      ReorderFavoriteTrackError,
      ReorderFavoriteTrackVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    undefined,
    ReorderFavoriteTrackError,
    ReorderFavoriteTrackVariables
  >({
    mutationFn: (variables: ReorderFavoriteTrackVariables) =>
      fetchReorderFavoriteTrack(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type FavoriteAlbumsError = Fetcher.ErrorWrapper<undefined>;

export type FavoriteAlbumsResponse = Schemas.SimpleAlbumDto[];

export type FavoriteAlbumsVariables = Context["fetcherOptions"];

export const fetchFavoriteAlbums = (
  variables: FavoriteAlbumsVariables,
  signal?: AbortSignal,
) =>
  fetch<FavoriteAlbumsResponse, FavoriteAlbumsError, undefined, {}, {}, {}>({
    url: "/api/favorites/albums",
    method: "get",
    ...variables,
    signal,
  });

export function favoriteAlbumsQuery(variables: FavoriteAlbumsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<FavoriteAlbumsResponse>;
};

export function favoriteAlbumsQuery(
  variables: FavoriteAlbumsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<FavoriteAlbumsResponse>)
    | reactQuery.SkipToken;
};

export function favoriteAlbumsQuery(
  variables: FavoriteAlbumsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/favorites/albums",
      operationId: "favoriteAlbums",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchFavoriteAlbums(variables, signal),
  };
}

export const useSuspenseFavoriteAlbums = <TData = FavoriteAlbumsResponse,>(
  variables: FavoriteAlbumsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      FavoriteAlbumsResponse,
      FavoriteAlbumsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    FavoriteAlbumsResponse,
    FavoriteAlbumsError,
    TData
  >({
    ...favoriteAlbumsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useFavoriteAlbums = <TData = FavoriteAlbumsResponse,>(
  variables: FavoriteAlbumsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      FavoriteAlbumsResponse,
      FavoriteAlbumsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    FavoriteAlbumsResponse,
    FavoriteAlbumsError,
    TData
  >({
    ...favoriteAlbumsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type FavoriteAlbumPathParams = {
  /**
   * @format uuid
   */
  albumId: string;
};

export type FavoriteAlbumError = Fetcher.ErrorWrapper<undefined>;

export type FavoriteAlbumVariables = {
  pathParams: FavoriteAlbumPathParams;
} & Context["fetcherOptions"];

export const fetchFavoriteAlbum = (
  variables: FavoriteAlbumVariables,
  signal?: AbortSignal,
) =>
  fetch<
    undefined,
    FavoriteAlbumError,
    undefined,
    {},
    {},
    FavoriteAlbumPathParams
  >({
    url: "/api/favorites/albums/{albumId}",
    method: "post",
    ...variables,
    signal,
  });

export const useFavoriteAlbum = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      FavoriteAlbumError,
      FavoriteAlbumVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    undefined,
    FavoriteAlbumError,
    FavoriteAlbumVariables
  >({
    mutationFn: (variables: FavoriteAlbumVariables) =>
      fetchFavoriteAlbum(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type RemoveFavoriteAlbumPathParams = {
  /**
   * @format uuid
   */
  albumId: string;
};

export type RemoveFavoriteAlbumError = Fetcher.ErrorWrapper<undefined>;

export type RemoveFavoriteAlbumVariables = {
  pathParams: RemoveFavoriteAlbumPathParams;
} & Context["fetcherOptions"];

export const fetchRemoveFavoriteAlbum = (
  variables: RemoveFavoriteAlbumVariables,
  signal?: AbortSignal,
) =>
  fetch<
    undefined,
    RemoveFavoriteAlbumError,
    undefined,
    {},
    {},
    RemoveFavoriteAlbumPathParams
  >({
    url: "/api/favorites/albums/{albumId}",
    method: "delete",
    ...variables,
    signal,
  });

export const useRemoveFavoriteAlbum = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      RemoveFavoriteAlbumError,
      RemoveFavoriteAlbumVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    undefined,
    RemoveFavoriteAlbumError,
    RemoveFavoriteAlbumVariables
  >({
    mutationFn: (variables: RemoveFavoriteAlbumVariables) =>
      fetchRemoveFavoriteAlbum(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type FavoriteArtistsError = Fetcher.ErrorWrapper<undefined>;

export type FavoriteArtistsResponse = Schemas.SimpleArtistDto[];

export type FavoriteArtistsVariables = Context["fetcherOptions"];

export const fetchFavoriteArtists = (
  variables: FavoriteArtistsVariables,
  signal?: AbortSignal,
) =>
  fetch<FavoriteArtistsResponse, FavoriteArtistsError, undefined, {}, {}, {}>({
    url: "/api/favorites/artists",
    method: "get",
    ...variables,
    signal,
  });

export function favoriteArtistsQuery(variables: FavoriteArtistsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<FavoriteArtistsResponse>;
};

export function favoriteArtistsQuery(
  variables: FavoriteArtistsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<FavoriteArtistsResponse>)
    | reactQuery.SkipToken;
};

export function favoriteArtistsQuery(
  variables: FavoriteArtistsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/favorites/artists",
      operationId: "favoriteArtists",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchFavoriteArtists(variables, signal),
  };
}

export const useSuspenseFavoriteArtists = <TData = FavoriteArtistsResponse,>(
  variables: FavoriteArtistsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      FavoriteArtistsResponse,
      FavoriteArtistsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    FavoriteArtistsResponse,
    FavoriteArtistsError,
    TData
  >({
    ...favoriteArtistsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useFavoriteArtists = <TData = FavoriteArtistsResponse,>(
  variables: FavoriteArtistsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      FavoriteArtistsResponse,
      FavoriteArtistsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    FavoriteArtistsResponse,
    FavoriteArtistsError,
    TData
  >({
    ...favoriteArtistsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type FavoriteArtistPathParams = {
  /**
   * @format uuid
   */
  artistId: string;
};

export type FavoriteArtistError = Fetcher.ErrorWrapper<undefined>;

export type FavoriteArtistVariables = {
  pathParams: FavoriteArtistPathParams;
} & Context["fetcherOptions"];

export const fetchFavoriteArtist = (
  variables: FavoriteArtistVariables,
  signal?: AbortSignal,
) =>
  fetch<
    undefined,
    FavoriteArtistError,
    undefined,
    {},
    {},
    FavoriteArtistPathParams
  >({
    url: "/api/favorites/artists/{artistId}",
    method: "post",
    ...variables,
    signal,
  });

export const useFavoriteArtist = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      FavoriteArtistError,
      FavoriteArtistVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    undefined,
    FavoriteArtistError,
    FavoriteArtistVariables
  >({
    mutationFn: (variables: FavoriteArtistVariables) =>
      fetchFavoriteArtist(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type RemoveFavoriteArtistPathParams = {
  /**
   * @format uuid
   */
  artistId: string;
};

export type RemoveFavoriteArtistError = Fetcher.ErrorWrapper<undefined>;

export type RemoveFavoriteArtistVariables = {
  pathParams: RemoveFavoriteArtistPathParams;
} & Context["fetcherOptions"];

export const fetchRemoveFavoriteArtist = (
  variables: RemoveFavoriteArtistVariables,
  signal?: AbortSignal,
) =>
  fetch<
    undefined,
    RemoveFavoriteArtistError,
    undefined,
    {},
    {},
    RemoveFavoriteArtistPathParams
  >({
    url: "/api/favorites/artists/{artistId}",
    method: "delete",
    ...variables,
    signal,
  });

export const useRemoveFavoriteArtist = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      RemoveFavoriteArtistError,
      RemoveFavoriteArtistVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    undefined,
    RemoveFavoriteArtistError,
    RemoveFavoriteArtistVariables
  >({
    mutationFn: (variables: RemoveFavoriteArtistVariables) =>
      fetchRemoveFavoriteArtist(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetSystemInfoError = Fetcher.ErrorWrapper<undefined>;

export type GetSystemInfoVariables = Context["fetcherOptions"];

export const fetchGetSystemInfo = (
  variables: GetSystemInfoVariables,
  signal?: AbortSignal,
) =>
  fetch<Schemas.SystemInfoDto, GetSystemInfoError, undefined, {}, {}, {}>({
    url: "/api/Onboarding/system-info",
    method: "get",
    ...variables,
    signal,
  });

export function getSystemInfoQuery(variables: GetSystemInfoVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.SystemInfoDto>;
};

export function getSystemInfoQuery(
  variables: GetSystemInfoVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.SystemInfoDto>)
    | reactQuery.SkipToken;
};

export function getSystemInfoQuery(
  variables: GetSystemInfoVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Onboarding/system-info",
      operationId: "getSystemInfo",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchGetSystemInfo(variables, signal),
  };
}

export const useSuspenseGetSystemInfo = <TData = Schemas.SystemInfoDto,>(
  variables: GetSystemInfoVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SystemInfoDto,
      GetSystemInfoError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.SystemInfoDto,
    GetSystemInfoError,
    TData
  >({
    ...getSystemInfoQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetSystemInfo = <TData = Schemas.SystemInfoDto,>(
  variables: GetSystemInfoVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SystemInfoDto,
      GetSystemInfoError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<Schemas.SystemInfoDto, GetSystemInfoError, TData>({
    ...getSystemInfoQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type ConfigureInferenceError = Fetcher.ErrorWrapper<undefined>;

export type ConfigureInferenceVariables = {
  body: Schemas.InferenceConfigRequest;
} & Context["fetcherOptions"];

export const fetchConfigureInference = (
  variables: ConfigureInferenceVariables,
  signal?: AbortSignal,
) =>
  fetch<
    undefined,
    ConfigureInferenceError,
    Schemas.InferenceConfigRequest,
    {},
    {},
    {}
  >({
    url: "/api/Onboarding/configure-inference",
    method: "post",
    ...variables,
    signal,
  });

export const useConfigureInference = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      ConfigureInferenceError,
      ConfigureInferenceVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    undefined,
    ConfigureInferenceError,
    ConfigureInferenceVariables
  >({
    mutationFn: (variables: ConfigureInferenceVariables) =>
      fetchConfigureInference(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type RootDirectoriesError = Fetcher.ErrorWrapper<undefined>;

export type RootDirectoriesResponse = string[];

export type RootDirectoriesVariables = Context["fetcherOptions"];

export const fetchRootDirectories = (
  variables: RootDirectoriesVariables,
  signal?: AbortSignal,
) =>
  fetch<RootDirectoriesResponse, RootDirectoriesError, undefined, {}, {}, {}>({
    url: "/api/Onboarding/root-directories",
    method: "get",
    ...variables,
    signal,
  });

export function rootDirectoriesQuery(variables: RootDirectoriesVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<RootDirectoriesResponse>;
};

export function rootDirectoriesQuery(
  variables: RootDirectoriesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<RootDirectoriesResponse>)
    | reactQuery.SkipToken;
};

export function rootDirectoriesQuery(
  variables: RootDirectoriesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Onboarding/root-directories",
      operationId: "rootDirectories",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchRootDirectories(variables, signal),
  };
}

export const useSuspenseRootDirectories = <TData = RootDirectoriesResponse,>(
  variables: RootDirectoriesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      RootDirectoriesResponse,
      RootDirectoriesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    RootDirectoriesResponse,
    RootDirectoriesError,
    TData
  >({
    ...rootDirectoriesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useRootDirectories = <TData = RootDirectoriesResponse,>(
  variables: RootDirectoriesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      RootDirectoriesResponse,
      RootDirectoriesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    RootDirectoriesResponse,
    RootDirectoriesError,
    TData
  >({
    ...rootDirectoriesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type DirectoriesInPathQueryParams = {
  path?: string;
};

export type DirectoriesInPathError = Fetcher.ErrorWrapper<undefined>;

export type DirectoriesInPathResponse = string[];

export type DirectoriesInPathVariables = {
  queryParams?: DirectoriesInPathQueryParams;
} & Context["fetcherOptions"];

export const fetchDirectoriesInPath = (
  variables: DirectoriesInPathVariables,
  signal?: AbortSignal,
) =>
  fetch<
    DirectoriesInPathResponse,
    DirectoriesInPathError,
    undefined,
    {},
    DirectoriesInPathQueryParams,
    {}
  >({
    url: "/api/Onboarding/list-directories",
    method: "get",
    ...variables,
    signal,
  });

export function directoriesInPathQuery(variables: DirectoriesInPathVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<DirectoriesInPathResponse>;
};

export function directoriesInPathQuery(
  variables: DirectoriesInPathVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<DirectoriesInPathResponse>)
    | reactQuery.SkipToken;
};

export function directoriesInPathQuery(
  variables: DirectoriesInPathVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Onboarding/list-directories",
      operationId: "directoriesInPath",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchDirectoriesInPath(variables, signal),
  };
}

export const useSuspenseDirectoriesInPath = <
  TData = DirectoriesInPathResponse,
>(
  variables: DirectoriesInPathVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      DirectoriesInPathResponse,
      DirectoriesInPathError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    DirectoriesInPathResponse,
    DirectoriesInPathError,
    TData
  >({
    ...directoriesInPathQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useDirectoriesInPath = <TData = DirectoriesInPathResponse,>(
  variables: DirectoriesInPathVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      DirectoriesInPathResponse,
      DirectoriesInPathError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    DirectoriesInPathResponse,
    DirectoriesInPathError,
    TData
  >({
    ...directoriesInPathQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type MusicLibrariesError = Fetcher.ErrorWrapper<undefined>;

export type MusicLibrariesResponse = Schemas.MusicLibraryDto[];

export type MusicLibrariesVariables = Context["fetcherOptions"];

export const fetchMusicLibraries = (
  variables: MusicLibrariesVariables,
  signal?: AbortSignal,
) =>
  fetch<MusicLibrariesResponse, MusicLibrariesError, undefined, {}, {}, {}>({
    url: "/api/Onboarding/music-libraries",
    method: "get",
    ...variables,
    signal,
  });

export function musicLibrariesQuery(variables: MusicLibrariesVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<MusicLibrariesResponse>;
};

export function musicLibrariesQuery(
  variables: MusicLibrariesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<MusicLibrariesResponse>)
    | reactQuery.SkipToken;
};

export function musicLibrariesQuery(
  variables: MusicLibrariesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Onboarding/music-libraries",
      operationId: "musicLibraries",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchMusicLibraries(variables, signal),
  };
}

export const useSuspenseMusicLibraries = <TData = MusicLibrariesResponse,>(
  variables: MusicLibrariesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      MusicLibrariesResponse,
      MusicLibrariesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    MusicLibrariesResponse,
    MusicLibrariesError,
    TData
  >({
    ...musicLibrariesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useMusicLibraries = <TData = MusicLibrariesResponse,>(
  variables: MusicLibrariesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      MusicLibrariesResponse,
      MusicLibrariesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    MusicLibrariesResponse,
    MusicLibrariesError,
    TData
  >({
    ...musicLibrariesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type RegisterMusicLibraryQueryParams = {
  path?: string;
};

export type RegisterMusicLibraryError = Fetcher.ErrorWrapper<undefined>;

export type RegisterMusicLibraryVariables = {
  queryParams?: RegisterMusicLibraryQueryParams;
} & Context["fetcherOptions"];

export const fetchRegisterMusicLibrary = (
  variables: RegisterMusicLibraryVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.MusicLibrary,
    RegisterMusicLibraryError,
    undefined,
    {},
    RegisterMusicLibraryQueryParams,
    {}
  >({ url: "/api/Onboarding/register", method: "post", ...variables, signal });

export const useRegisterMusicLibrary = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MusicLibrary,
      RegisterMusicLibraryError,
      RegisterMusicLibraryVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    Schemas.MusicLibrary,
    RegisterMusicLibraryError,
    RegisterMusicLibraryVariables
  >({
    mutationFn: (variables: RegisterMusicLibraryVariables) =>
      fetchRegisterMusicLibrary(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type LoadAllPluginsError = Fetcher.ErrorWrapper<undefined>;

export type LoadAllPluginsVariables = Context["fetcherOptions"];

export const fetchLoadAllPlugins = (
  variables: LoadAllPluginsVariables,
  signal?: AbortSignal,
) =>
  fetch<undefined, LoadAllPluginsError, undefined, {}, {}, {}>({
    url: "/api/Plugin/load",
    method: "get",
    ...variables,
    signal,
  });

export function loadAllPluginsQuery(variables: LoadAllPluginsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function loadAllPluginsQuery(
  variables: LoadAllPluginsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function loadAllPluginsQuery(
  variables: LoadAllPluginsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Plugin/load",
      operationId: "loadAllPlugins",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchLoadAllPlugins(variables, signal),
  };
}

export const useSuspenseLoadAllPlugins = <TData = undefined,>(
  variables: LoadAllPluginsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, LoadAllPluginsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<undefined, LoadAllPluginsError, TData>({
    ...loadAllPluginsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useLoadAllPlugins = <TData = undefined,>(
  variables: LoadAllPluginsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, LoadAllPluginsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<undefined, LoadAllPluginsError, TData>({
    ...loadAllPluginsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type UnloadPluginsError = Fetcher.ErrorWrapper<undefined>;

export type UnloadPluginsVariables = Context["fetcherOptions"];

export const fetchUnloadPlugins = (
  variables: UnloadPluginsVariables,
  signal?: AbortSignal,
) =>
  fetch<undefined, UnloadPluginsError, undefined, {}, {}, {}>({
    url: "/api/Plugin/unload",
    method: "get",
    ...variables,
    signal,
  });

export function unloadPluginsQuery(variables: UnloadPluginsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function unloadPluginsQuery(
  variables: UnloadPluginsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function unloadPluginsQuery(
  variables: UnloadPluginsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Plugin/unload",
      operationId: "unloadPlugins",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchUnloadPlugins(variables, signal),
  };
}

export const useSuspenseUnloadPlugins = <TData = undefined,>(
  variables: UnloadPluginsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, UnloadPluginsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<undefined, UnloadPluginsError, TData>({
    ...unloadPluginsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useUnloadPlugins = <TData = undefined,>(
  variables: UnloadPluginsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, UnloadPluginsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<undefined, UnloadPluginsError, TData>({
    ...unloadPluginsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type RunIndexerError = Fetcher.ErrorWrapper<undefined>;

export type RunIndexerVariables = Context["fetcherOptions"];

export const fetchRunIndexer = (
  variables: RunIndexerVariables,
  signal?: AbortSignal,
) =>
  fetch<Schemas.ScanInitiatedDto, RunIndexerError, undefined, {}, {}, {}>({
    url: "/api/scan",
    method: "post",
    ...variables,
    signal,
  });

export const useRunIndexer = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.ScanInitiatedDto,
      RunIndexerError,
      RunIndexerVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    Schemas.ScanInitiatedDto,
    RunIndexerError,
    RunIndexerVariables
  >({
    mutationFn: (variables: RunIndexerVariables) =>
      fetchRunIndexer(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type GetScanProgressPathParams = {
  /**
   * @format uuid
   */
  requestId: string;
};

export type GetScanProgressError = Fetcher.ErrorWrapper<undefined>;

export type GetScanProgressVariables = {
  pathParams: GetScanProgressPathParams;
} & Context["fetcherOptions"];

export const fetchGetScanProgress = (
  variables: GetScanProgressVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.ScanJobProgress,
    GetScanProgressError,
    undefined,
    {},
    {},
    GetScanProgressPathParams
  >({
    url: "/api/scan/progress/{requestId}",
    method: "get",
    ...variables,
    signal,
  });

export function getScanProgressQuery(variables: GetScanProgressVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.ScanJobProgress>;
};

export function getScanProgressQuery(
  variables: GetScanProgressVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.ScanJobProgress>)
    | reactQuery.SkipToken;
};

export function getScanProgressQuery(
  variables: GetScanProgressVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/scan/progress/{requestId}",
      operationId: "getScanProgress",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetScanProgress(variables, signal),
  };
}

export const useSuspenseGetScanProgress = <TData = Schemas.ScanJobProgress,>(
  variables: GetScanProgressVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ScanJobProgress,
      GetScanProgressError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.ScanJobProgress,
    GetScanProgressError,
    TData
  >({
    ...getScanProgressQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetScanProgress = <TData = Schemas.ScanJobProgress,>(
  variables: GetScanProgressVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.ScanJobProgress,
      GetScanProgressError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    Schemas.ScanJobProgress,
    GetScanProgressError,
    TData
  >({
    ...getScanProgressQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetActiveScansError = Fetcher.ErrorWrapper<undefined>;

export type GetActiveScansResponse = Schemas.ScanJobProgress[];

export type GetActiveScansVariables = Context["fetcherOptions"];

export const fetchGetActiveScans = (
  variables: GetActiveScansVariables,
  signal?: AbortSignal,
) =>
  fetch<GetActiveScansResponse, GetActiveScansError, undefined, {}, {}, {}>({
    url: "/api/scan/active",
    method: "get",
    ...variables,
    signal,
  });

export function getActiveScansQuery(variables: GetActiveScansVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<GetActiveScansResponse>;
};

export function getActiveScansQuery(
  variables: GetActiveScansVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<GetActiveScansResponse>)
    | reactQuery.SkipToken;
};

export function getActiveScansQuery(
  variables: GetActiveScansVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/scan/active",
      operationId: "getActiveScans",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetActiveScans(variables, signal),
  };
}

export const useSuspenseGetActiveScans = <TData = GetActiveScansResponse,>(
  variables: GetActiveScansVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetActiveScansResponse,
      GetActiveScansError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    GetActiveScansResponse,
    GetActiveScansError,
    TData
  >({
    ...getActiveScansQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetActiveScans = <TData = GetActiveScansResponse,>(
  variables: GetActiveScansVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      GetActiveScansResponse,
      GetActiveScansError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    GetActiveScansResponse,
    GetActiveScansError,
    TData
  >({
    ...getActiveScansQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type SearchQueryParams = {
  query?: string;
  /**
   * @format int32
   * @default 0
   */
  offset?: number;
  /**
   * @format int32
   * @default 100
   */
  limit?: number;
};

export type SearchError = Fetcher.ErrorWrapper<undefined>;

export type SearchVariables = {
  queryParams?: SearchQueryParams;
} & Context["fetcherOptions"];

export const fetchSearch = (variables: SearchVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.SearchResultPaginatedCustomData,
    SearchError,
    undefined,
    {},
    SearchQueryParams,
    {}
  >({ url: "/api/search", method: "get", ...variables, signal });

export function searchQuery(variables: SearchVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<Schemas.SearchResultPaginatedCustomData>;
};

export function searchQuery(
  variables: SearchVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<Schemas.SearchResultPaginatedCustomData>)
    | reactQuery.SkipToken;
};

export function searchQuery(variables: SearchVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: "/api/search",
      operationId: "search",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchSearch(variables, signal),
  };
}

export const useSuspenseSearch = <
  TData = Schemas.SearchResultPaginatedCustomData,
>(
  variables: SearchVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SearchResultPaginatedCustomData,
      SearchError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.SearchResultPaginatedCustomData,
    SearchError,
    TData
  >({
    ...searchQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useSearch = <TData = Schemas.SearchResultPaginatedCustomData,>(
  variables: SearchVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SearchResultPaginatedCustomData,
      SearchError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    Schemas.SearchResultPaginatedCustomData,
    SearchError,
    TData
  >({
    ...searchQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type StreamFilePathParams = {
  /**
   * @format uuid
   */
  trackId: string;
};

export type StreamFileQueryParams = {
  /**
   * @format int64
   */
  expires?: number;
  signature?: string;
};

export type StreamFileError = Fetcher.ErrorWrapper<undefined>;

export type StreamFileVariables = {
  pathParams: StreamFilePathParams;
  queryParams?: StreamFileQueryParams;
} & Context["fetcherOptions"];

export const fetchStreamFile = (
  variables: StreamFileVariables,
  signal?: AbortSignal,
) =>
  fetch<
    undefined,
    StreamFileError,
    undefined,
    {},
    StreamFileQueryParams,
    StreamFilePathParams
  >({ url: "/api/stream/{trackId}", method: "get", ...variables, signal });

export function streamFileQuery(variables: StreamFileVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function streamFileQuery(
  variables: StreamFileVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function streamFileQuery(
  variables: StreamFileVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/stream/{trackId}",
      operationId: "streamFile",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchStreamFile(variables, signal),
  };
}

export const useSuspenseStreamFile = <TData = undefined,>(
  variables: StreamFileVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, StreamFileError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<undefined, StreamFileError, TData>({
    ...streamFileQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useStreamFile = <TData = undefined,>(
  variables: StreamFileVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, StreamFileError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<undefined, StreamFileError, TData>({
    ...streamFileQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type GetOriginalStreamUrlPathParams = {
  /**
   * @format uuid
   */
  trackId: string;
};

export type GetOriginalStreamUrlError = Fetcher.ErrorWrapper<undefined>;

export type GetOriginalStreamUrlVariables = {
  pathParams: GetOriginalStreamUrlPathParams;
} & Context["fetcherOptions"];

export const fetchGetOriginalStreamUrl = (
  variables: GetOriginalStreamUrlVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.StreamDto,
    GetOriginalStreamUrlError,
    undefined,
    {},
    {},
    GetOriginalStreamUrlPathParams
  >({
    url: "/api/stream/tracks/{trackId}/original",
    method: "get",
    ...variables,
    signal,
  });

export function getOriginalStreamUrlQuery(
  variables: GetOriginalStreamUrlVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.StreamDto>;
};

export function getOriginalStreamUrlQuery(
  variables: GetOriginalStreamUrlVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.StreamDto>)
    | reactQuery.SkipToken;
};

export function getOriginalStreamUrlQuery(
  variables: GetOriginalStreamUrlVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/stream/tracks/{trackId}/original",
      operationId: "getOriginalStreamUrl",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchGetOriginalStreamUrl(variables, signal),
  };
}

export const useSuspenseGetOriginalStreamUrl = <TData = Schemas.StreamDto,>(
  variables: GetOriginalStreamUrlVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.StreamDto,
      GetOriginalStreamUrlError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.StreamDto,
    GetOriginalStreamUrlError,
    TData
  >({
    ...getOriginalStreamUrlQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useGetOriginalStreamUrl = <TData = Schemas.StreamDto,>(
  variables: GetOriginalStreamUrlVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.StreamDto,
      GetOriginalStreamUrlError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    Schemas.StreamDto,
    GetOriginalStreamUrlError,
    TData
  >({
    ...getOriginalStreamUrlQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type TranscodeTrackPathParams = {
  /**
   * @format uuid
   */
  trackId: string;
};

export type TranscodeTrackQueryParams = {
  /**
   * @format int32
   */
  bitrate?: number;
};

export type TranscodeTrackError = Fetcher.ErrorWrapper<undefined>;

export type TranscodeTrackVariables = {
  pathParams: TranscodeTrackPathParams;
  queryParams?: TranscodeTrackQueryParams;
} & Context["fetcherOptions"];

export const fetchTranscodeTrack = (
  variables: TranscodeTrackVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.StreamDto,
    TranscodeTrackError,
    undefined,
    {},
    TranscodeTrackQueryParams,
    TranscodeTrackPathParams
  >({
    url: "/api/stream/tracks/{trackId}/transcode",
    method: "get",
    ...variables,
    signal,
  });

export function transcodeTrackQuery(variables: TranscodeTrackVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.StreamDto>;
};

export function transcodeTrackQuery(
  variables: TranscodeTrackVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.StreamDto>)
    | reactQuery.SkipToken;
};

export function transcodeTrackQuery(
  variables: TranscodeTrackVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/stream/tracks/{trackId}/transcode",
      operationId: "transcodeTrack",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchTranscodeTrack(variables, signal),
  };
}

export const useSuspenseTranscodeTrack = <TData = Schemas.StreamDto,>(
  variables: TranscodeTrackVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.StreamDto, TranscodeTrackError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.StreamDto,
    TranscodeTrackError,
    TData
  >({
    ...transcodeTrackQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useTranscodeTrack = <TData = Schemas.StreamDto,>(
  variables: TranscodeTrackVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.StreamDto, TranscodeTrackError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<Schemas.StreamDto, TranscodeTrackError, TData>({
    ...transcodeTrackQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type StreamTrackPathParams = {
  /**
   * @format uuid
   */
  trackId: string;
};

export type StreamTrackError = Fetcher.ErrorWrapper<undefined>;

export type StreamTrackVariables = {
  pathParams: StreamTrackPathParams;
} & Context["fetcherOptions"];

export const fetchStreamTrack = (
  variables: StreamTrackVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.StreamDto,
    StreamTrackError,
    undefined,
    {},
    {},
    StreamTrackPathParams
  >({
    url: "/api/stream/tracks/{trackId}/hls",
    method: "get",
    ...variables,
    signal,
  });

export function streamTrackQuery(variables: StreamTrackVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.StreamDto>;
};

export function streamTrackQuery(
  variables: StreamTrackVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.StreamDto>)
    | reactQuery.SkipToken;
};

export function streamTrackQuery(
  variables: StreamTrackVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/stream/tracks/{trackId}/hls",
      operationId: "streamTrack",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchStreamTrack(variables, signal),
  };
}

export const useSuspenseStreamTrack = <TData = Schemas.StreamDto,>(
  variables: StreamTrackVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.StreamDto, StreamTrackError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.StreamDto,
    StreamTrackError,
    TData
  >({
    ...streamTrackQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useStreamTrack = <TData = Schemas.StreamDto,>(
  variables: StreamTrackVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.StreamDto, StreamTrackError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<Schemas.StreamDto, StreamTrackError, TData>({
    ...streamTrackQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type TracksError = Fetcher.ErrorWrapper<undefined>;

export type TracksResponse = Schemas.TrackDto[];

export type TracksVariables = Context["fetcherOptions"];

export const fetchTracks = (variables: TracksVariables, signal?: AbortSignal) =>
  fetch<TracksResponse, TracksError, undefined, {}, {}, {}>({
    url: "/api/tracks",
    method: "get",
    ...variables,
    signal,
  });

export function tracksQuery(variables: TracksVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<TracksResponse>;
};

export function tracksQuery(
  variables: TracksVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<TracksResponse>)
    | reactQuery.SkipToken;
};

export function tracksQuery(variables: TracksVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: "/api/tracks",
      operationId: "tracks",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchTracks(variables, signal),
  };
}

export const useSuspenseTracks = <TData = TracksResponse,>(
  variables: TracksVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<TracksResponse, TracksError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<TracksResponse, TracksError, TData>({
    ...tracksQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useTracks = <TData = TracksResponse,>(
  variables: TracksVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<TracksResponse, TracksError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<TracksResponse, TracksError, TData>({
    ...tracksQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type LogPlaybackPathParams = {
  /**
   * @format uuid
   */
  trackId: string;
};

export type LogPlaybackError = Fetcher.ErrorWrapper<undefined>;

export type LogPlaybackVariables = {
  pathParams: LogPlaybackPathParams;
} & Context["fetcherOptions"];

export const fetchLogPlayback = (
  variables: LogPlaybackVariables,
  signal?: AbortSignal,
) =>
  fetch<undefined, LogPlaybackError, undefined, {}, {}, LogPlaybackPathParams>({
    url: "/api/tracks/{trackId}/log-playback",
    method: "post",
    ...variables,
    signal,
  });

export const useLogPlayback = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      LogPlaybackError,
      LogPlaybackVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    undefined,
    LogPlaybackError,
    LogPlaybackVariables
  >({
    mutationFn: (variables: LogPlaybackVariables) =>
      fetchLogPlayback(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type RecommendationsForTrackPathParams = {
  /**
   * @format uuid
   */
  trackId: string;
};

export type RecommendationsForTrackError = Fetcher.ErrorWrapper<undefined>;

export type RecommendationsForTrackResponse = Schemas.SimpleTrackDto[];

export type RecommendationsForTrackVariables = {
  pathParams: RecommendationsForTrackPathParams;
} & Context["fetcherOptions"];

export const fetchRecommendationsForTrack = (
  variables: RecommendationsForTrackVariables,
  signal?: AbortSignal,
) =>
  fetch<
    RecommendationsForTrackResponse,
    RecommendationsForTrackError,
    undefined,
    {},
    {},
    RecommendationsForTrackPathParams
  >({
    url: "/api/tracks/{trackId}/recommendations",
    method: "get",
    ...variables,
    signal,
  });

export function recommendationsForTrackQuery(
  variables: RecommendationsForTrackVariables,
): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<RecommendationsForTrackResponse>;
};

export function recommendationsForTrackQuery(
  variables: RecommendationsForTrackVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<RecommendationsForTrackResponse>)
    | reactQuery.SkipToken;
};

export function recommendationsForTrackQuery(
  variables: RecommendationsForTrackVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/tracks/{trackId}/recommendations",
      operationId: "recommendationsForTrack",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchRecommendationsForTrack(variables, signal),
  };
}

export const useSuspenseRecommendationsForTrack = <
  TData = RecommendationsForTrackResponse,
>(
  variables: RecommendationsForTrackVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      RecommendationsForTrackResponse,
      RecommendationsForTrackError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    RecommendationsForTrackResponse,
    RecommendationsForTrackError,
    TData
  >({
    ...recommendationsForTrackQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useRecommendationsForTrack = <
  TData = RecommendationsForTrackResponse,
>(
  variables: RecommendationsForTrackVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      RecommendationsForTrackResponse,
      RecommendationsForTrackError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    RecommendationsForTrackResponse,
    RecommendationsForTrackError,
    TData
  >({
    ...recommendationsForTrackQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type QueryOperation =
  | {
      path: "/api/albums";
      operationId: "albums";
      variables: AlbumsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/albums/all";
      operationId: "allAlbums";
      variables: AllAlbumsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/albums/recently-added";
      operationId: "recentlyAddedAlbums";
      variables: RecentlyAddedAlbumsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/albums/{albumId}";
      operationId: "album";
      variables: AlbumVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/albums/{albumId}/tracks";
      operationId: "albumTracks";
      variables: AlbumTracksVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/albums/{albumId}/recommendations";
      operationId: "recommendationsForAlbum";
      variables: RecommendationsForAlbumVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/artists";
      operationId: "artists";
      variables: ArtistsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/artists/{artistId}";
      operationId: "artist";
      variables: ArtistVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Artwork";
      operationId: "getArtwork";
      variables: GetArtworkVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Artwork/{artworkId}";
      operationId: "artworkFromId";
      variables: ArtworkFromIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Auth/status";
      operationId: "getStatus";
      variables: GetStatusVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Auth/me";
      operationId: "getCurrentUser";
      variables: GetCurrentUserVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Configuration";
      operationId: "getConfiguration";
      variables: GetConfigurationVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Devices";
      operationId: "getDevices";
      variables: GetDevicesVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/favorites/tracks";
      operationId: "favoriteTracks";
      variables: FavoriteTracksVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/favorites/albums";
      operationId: "favoriteAlbums";
      variables: FavoriteAlbumsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/favorites/artists";
      operationId: "favoriteArtists";
      variables: FavoriteArtistsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Onboarding/system-info";
      operationId: "getSystemInfo";
      variables: GetSystemInfoVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Onboarding/root-directories";
      operationId: "rootDirectories";
      variables: RootDirectoriesVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Onboarding/list-directories";
      operationId: "directoriesInPath";
      variables: DirectoriesInPathVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Onboarding/music-libraries";
      operationId: "musicLibraries";
      variables: MusicLibrariesVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Plugin/load";
      operationId: "loadAllPlugins";
      variables: LoadAllPluginsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Plugin/unload";
      operationId: "unloadPlugins";
      variables: UnloadPluginsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/scan/progress/{requestId}";
      operationId: "getScanProgress";
      variables: GetScanProgressVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/scan/active";
      operationId: "getActiveScans";
      variables: GetActiveScansVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/search";
      operationId: "search";
      variables: SearchVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/stream/{trackId}";
      operationId: "streamFile";
      variables: StreamFileVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/stream/tracks/{trackId}/original";
      operationId: "getOriginalStreamUrl";
      variables: GetOriginalStreamUrlVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/stream/tracks/{trackId}/transcode";
      operationId: "transcodeTrack";
      variables: TranscodeTrackVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/stream/tracks/{trackId}/hls";
      operationId: "streamTrack";
      variables: StreamTrackVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/tracks";
      operationId: "tracks";
      variables: TracksVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/tracks/{trackId}/recommendations";
      operationId: "recommendationsForTrack";
      variables: RecommendationsForTrackVariables | reactQuery.SkipToken;
    };
