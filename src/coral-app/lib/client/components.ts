/**
 * Generated by @openapi-codegen
 *
 * @version v1
 */
import * as reactQuery from "@tanstack/react-query";
import { useContext, Context, queryKeyFn } from "./context";
import { deepMerge } from "./utils";
import type * as Fetcher from "./fetcher";
import { fetch } from "./fetcher";
import type * as Schemas from "./schemas";

type QueryFnOptions = {
  signal?: AbortController["signal"];
};

export type ArtworkFromIdPathParams = {
  /**
   * @format uuid
   */
  artworkId: string;
};

export type ArtworkFromIdError = Fetcher.ErrorWrapper<undefined>;

export type ArtworkFromIdVariables = {
  pathParams: ArtworkFromIdPathParams;
} & Context["fetcherOptions"];

export const fetchArtworkFromId = (
  variables: ArtworkFromIdVariables,
  signal?: AbortSignal,
) =>
  fetch<
    undefined,
    ArtworkFromIdError,
    undefined,
    {},
    {},
    ArtworkFromIdPathParams
  >({ url: "/api/Artwork/{artworkId}", method: "get", ...variables, signal });

export function artworkFromIdQuery(variables: ArtworkFromIdVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function artworkFromIdQuery(
  variables: ArtworkFromIdVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function artworkFromIdQuery(
  variables: ArtworkFromIdVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Artwork/{artworkId}",
      operationId: "artworkFromId",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchArtworkFromId(variables, signal),
  };
}

export const useSuspenseArtworkFromId = <TData = undefined,>(
  variables: ArtworkFromIdVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, ArtworkFromIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<undefined, ArtworkFromIdError, TData>({
    ...artworkFromIdQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useArtworkFromId = <TData = undefined,>(
  variables: ArtworkFromIdVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, ArtworkFromIdError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<undefined, ArtworkFromIdError, TData>({
    ...artworkFromIdQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type RunIndexerError = Fetcher.ErrorWrapper<undefined>;

export type RunIndexerVariables = Context["fetcherOptions"];

export const fetchRunIndexer = (
  variables: RunIndexerVariables,
  signal?: AbortSignal,
) =>
  fetch<undefined, RunIndexerError, undefined, {}, {}, {}>({
    url: "/api/Library/scan",
    method: "post",
    ...variables,
    signal,
  });

export const useRunIndexer = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      undefined,
      RunIndexerError,
      RunIndexerVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    undefined,
    RunIndexerError,
    RunIndexerVariables
  >({
    mutationFn: (variables: RunIndexerVariables) =>
      fetchRunIndexer(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type SearchQueryParams = {
  query?: string;
  /**
   * @format int32
   * @default 0
   */
  offset?: number;
  /**
   * @format int32
   * @default 100
   */
  limit?: number;
};

export type SearchError = Fetcher.ErrorWrapper<undefined>;

export type SearchVariables = {
  queryParams?: SearchQueryParams;
} & Context["fetcherOptions"];

export const fetchSearch = (variables: SearchVariables, signal?: AbortSignal) =>
  fetch<
    Schemas.SearchResultPaginatedCustomData,
    SearchError,
    undefined,
    {},
    SearchQueryParams,
    {}
  >({ url: "/api/Library/search", method: "get", ...variables, signal });

export function searchQuery(variables: SearchVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<Schemas.SearchResultPaginatedCustomData>;
};

export function searchQuery(
  variables: SearchVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<Schemas.SearchResultPaginatedCustomData>)
    | reactQuery.SkipToken;
};

export function searchQuery(variables: SearchVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Library/search",
      operationId: "search",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchSearch(variables, signal),
  };
}

export const useSuspenseSearch = <
  TData = Schemas.SearchResultPaginatedCustomData,
>(
  variables: SearchVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SearchResultPaginatedCustomData,
      SearchError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.SearchResultPaginatedCustomData,
    SearchError,
    TData
  >({
    ...searchQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useSearch = <TData = Schemas.SearchResultPaginatedCustomData,>(
  variables: SearchVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SearchResultPaginatedCustomData,
      SearchError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    Schemas.SearchResultPaginatedCustomData,
    SearchError,
    TData
  >({
    ...searchQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type LogPlaybackPathParams = {
  /**
   * @format uuid
   */
  trackId: string;
};

export type LogPlaybackError = Fetcher.ErrorWrapper<undefined>;

export type LogPlaybackVariables = {
  pathParams: LogPlaybackPathParams;
} & Context["fetcherOptions"];

export const fetchLogPlayback = (
  variables: LogPlaybackVariables,
  signal?: AbortSignal,
) =>
  fetch<undefined, LogPlaybackError, undefined, {}, {}, LogPlaybackPathParams>({
    url: "/api/Library/tracks/{trackId}/logPlayback",
    method: "get",
    ...variables,
    signal,
  });

export function logPlaybackQuery(variables: LogPlaybackVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function logPlaybackQuery(
  variables: LogPlaybackVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function logPlaybackQuery(
  variables: LogPlaybackVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Library/tracks/{trackId}/logPlayback",
      operationId: "logPlayback",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchLogPlayback(variables, signal),
  };
}

export const useSuspenseLogPlayback = <TData = undefined,>(
  variables: LogPlaybackVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, LogPlaybackError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<undefined, LogPlaybackError, TData>({
    ...logPlaybackQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useLogPlayback = <TData = undefined,>(
  variables: LogPlaybackVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, LogPlaybackError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<undefined, LogPlaybackError, TData>({
    ...logPlaybackQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type FileFromLibraryPathParams = {
  /**
   * @format uuid
   */
  trackId: string;
};

export type FileFromLibraryError = Fetcher.ErrorWrapper<undefined>;

export type FileFromLibraryVariables = {
  pathParams: FileFromLibraryPathParams;
} & Context["fetcherOptions"];

export const fetchFileFromLibrary = (
  variables: FileFromLibraryVariables,
  signal?: AbortSignal,
) =>
  fetch<
    undefined,
    FileFromLibraryError,
    undefined,
    {},
    {},
    FileFromLibraryPathParams
  >({
    url: "/api/Library/tracks/{trackId}/original",
    method: "get",
    ...variables,
    signal,
  });

export function fileFromLibraryQuery(variables: FileFromLibraryVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function fileFromLibraryQuery(
  variables: FileFromLibraryVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function fileFromLibraryQuery(
  variables: FileFromLibraryVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Library/tracks/{trackId}/original",
      operationId: "fileFromLibrary",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchFileFromLibrary(variables, signal),
  };
}

export const useSuspenseFileFromLibrary = <TData = undefined,>(
  variables: FileFromLibraryVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, FileFromLibraryError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<undefined, FileFromLibraryError, TData>({
    ...fileFromLibraryQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useFileFromLibrary = <TData = undefined,>(
  variables: FileFromLibraryVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, FileFromLibraryError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<undefined, FileFromLibraryError, TData>({
    ...fileFromLibraryQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type TranscodeTrackPathParams = {
  /**
   * @format uuid
   */
  trackId: string;
};

export type TranscodeTrackQueryParams = {
  /**
   * @format int32
   */
  bitrate?: number;
};

export type TranscodeTrackError = Fetcher.ErrorWrapper<undefined>;

export type TranscodeTrackVariables = {
  pathParams: TranscodeTrackPathParams;
  queryParams?: TranscodeTrackQueryParams;
} & Context["fetcherOptions"];

export const fetchTranscodeTrack = (
  variables: TranscodeTrackVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.StreamDto,
    TranscodeTrackError,
    undefined,
    {},
    TranscodeTrackQueryParams,
    TranscodeTrackPathParams
  >({
    url: "/api/Library/tracks/{trackId}/transcode",
    method: "get",
    ...variables,
    signal,
  });

export function transcodeTrackQuery(variables: TranscodeTrackVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.StreamDto>;
};

export function transcodeTrackQuery(
  variables: TranscodeTrackVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.StreamDto>)
    | reactQuery.SkipToken;
};

export function transcodeTrackQuery(
  variables: TranscodeTrackVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Library/tracks/{trackId}/transcode",
      operationId: "transcodeTrack",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchTranscodeTrack(variables, signal),
  };
}

export const useSuspenseTranscodeTrack = <TData = Schemas.StreamDto,>(
  variables: TranscodeTrackVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.StreamDto, TranscodeTrackError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.StreamDto,
    TranscodeTrackError,
    TData
  >({
    ...transcodeTrackQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useTranscodeTrack = <TData = Schemas.StreamDto,>(
  variables: TranscodeTrackVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.StreamDto, TranscodeTrackError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<Schemas.StreamDto, TranscodeTrackError, TData>({
    ...transcodeTrackQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type StreamTrackPathParams = {
  /**
   * @format uuid
   */
  trackId: string;
};

export type StreamTrackQueryParams = {
  /**
   * @format int32
   * @default 192
   */
  bitrate?: number;
  /**
   * @default true
   */
  transcodeTrack?: boolean;
};

export type StreamTrackError = Fetcher.ErrorWrapper<undefined>;

export type StreamTrackVariables = {
  pathParams: StreamTrackPathParams;
  queryParams?: StreamTrackQueryParams;
} & Context["fetcherOptions"];

export const fetchStreamTrack = (
  variables: StreamTrackVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.StreamDto,
    StreamTrackError,
    undefined,
    {},
    StreamTrackQueryParams,
    StreamTrackPathParams
  >({
    url: "/api/Library/tracks/{trackId}/stream",
    method: "get",
    ...variables,
    signal,
  });

export function streamTrackQuery(variables: StreamTrackVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.StreamDto>;
};

export function streamTrackQuery(
  variables: StreamTrackVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.StreamDto>)
    | reactQuery.SkipToken;
};

export function streamTrackQuery(
  variables: StreamTrackVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Library/tracks/{trackId}/stream",
      operationId: "streamTrack",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchStreamTrack(variables, signal),
  };
}

export const useSuspenseStreamTrack = <TData = Schemas.StreamDto,>(
  variables: StreamTrackVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.StreamDto, StreamTrackError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.StreamDto,
    StreamTrackError,
    TData
  >({
    ...streamTrackQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useStreamTrack = <TData = Schemas.StreamDto,>(
  variables: StreamTrackVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.StreamDto, StreamTrackError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<Schemas.StreamDto, StreamTrackError, TData>({
    ...streamTrackQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type TracksError = Fetcher.ErrorWrapper<undefined>;

export type TracksResponse = Schemas.TrackDto[];

export type TracksVariables = Context["fetcherOptions"];

export const fetchTracks = (variables: TracksVariables, signal?: AbortSignal) =>
  fetch<TracksResponse, TracksError, undefined, {}, {}, {}>({
    url: "/api/Library/tracks",
    method: "get",
    ...variables,
    signal,
  });

export function tracksQuery(variables: TracksVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<TracksResponse>;
};

export function tracksQuery(
  variables: TracksVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<TracksResponse>)
    | reactQuery.SkipToken;
};

export function tracksQuery(variables: TracksVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Library/tracks",
      operationId: "tracks",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchTracks(variables, signal),
  };
}

export const useSuspenseTracks = <TData = TracksResponse,>(
  variables: TracksVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<TracksResponse, TracksError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<TracksResponse, TracksError, TData>({
    ...tracksQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useTracks = <TData = TracksResponse,>(
  variables: TracksVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<TracksResponse, TracksError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<TracksResponse, TracksError, TData>({
    ...tracksQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type AlbumsError = Fetcher.ErrorWrapper<undefined>;

export type AlbumsResponse = Schemas.SimpleAlbumDto[];

export type AlbumsVariables = Context["fetcherOptions"];

export const fetchAlbums = (variables: AlbumsVariables, signal?: AbortSignal) =>
  fetch<AlbumsResponse, AlbumsError, undefined, {}, {}, {}>({
    url: "/api/Library/albums",
    method: "get",
    ...variables,
    signal,
  });

export function albumsQuery(variables: AlbumsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<AlbumsResponse>;
};

export function albumsQuery(
  variables: AlbumsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<AlbumsResponse>)
    | reactQuery.SkipToken;
};

export function albumsQuery(variables: AlbumsVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Library/albums",
      operationId: "albums",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchAlbums(variables, signal),
  };
}

export const useSuspenseAlbums = <TData = AlbumsResponse,>(
  variables: AlbumsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<AlbumsResponse, AlbumsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<AlbumsResponse, AlbumsError, TData>({
    ...albumsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useAlbums = <TData = AlbumsResponse,>(
  variables: AlbumsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<AlbumsResponse, AlbumsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<AlbumsResponse, AlbumsError, TData>({
    ...albumsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PaginatedAlbumsQueryParams = {
  /**
   * @format int32
   * @default 10
   */
  limit?: number;
  /**
   * @format int32
   * @default 0
   */
  offset?: number;
};

export type PaginatedAlbumsError = Fetcher.ErrorWrapper<undefined>;

export type PaginatedAlbumsVariables = {
  queryParams?: PaginatedAlbumsQueryParams;
} & Context["fetcherOptions"];

export const fetchPaginatedAlbums = (
  variables: PaginatedAlbumsVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.SimpleAlbumDtoPaginatedQuery,
    PaginatedAlbumsError,
    undefined,
    {},
    PaginatedAlbumsQueryParams,
    {}
  >({
    url: "/api/Library/albums/paginated",
    method: "get",
    ...variables,
    signal,
  });

export function paginatedAlbumsQuery(variables: PaginatedAlbumsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<Schemas.SimpleAlbumDtoPaginatedQuery>;
};

export function paginatedAlbumsQuery(
  variables: PaginatedAlbumsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<Schemas.SimpleAlbumDtoPaginatedQuery>)
    | reactQuery.SkipToken;
};

export function paginatedAlbumsQuery(
  variables: PaginatedAlbumsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Library/albums/paginated",
      operationId: "paginatedAlbums",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchPaginatedAlbums(variables, signal),
  };
}

export const useSuspensePaginatedAlbums = <
  TData = Schemas.SimpleAlbumDtoPaginatedQuery,
>(
  variables: PaginatedAlbumsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SimpleAlbumDtoPaginatedQuery,
      PaginatedAlbumsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.SimpleAlbumDtoPaginatedQuery,
    PaginatedAlbumsError,
    TData
  >({
    ...paginatedAlbumsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const usePaginatedAlbums = <
  TData = Schemas.SimpleAlbumDtoPaginatedQuery,
>(
  variables: PaginatedAlbumsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SimpleAlbumDtoPaginatedQuery,
      PaginatedAlbumsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    Schemas.SimpleAlbumDtoPaginatedQuery,
    PaginatedAlbumsError,
    TData
  >({
    ...paginatedAlbumsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type PaginatedArtistsQueryParams = {
  /**
   * @format int32
   * @default 10
   */
  limit?: number;
  /**
   * @format int32
   * @default 0
   */
  offset?: number;
};

export type PaginatedArtistsError = Fetcher.ErrorWrapper<undefined>;

export type PaginatedArtistsVariables = {
  queryParams?: PaginatedArtistsQueryParams;
} & Context["fetcherOptions"];

export const fetchPaginatedArtists = (
  variables: PaginatedArtistsVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.SimpleArtistDtoPaginatedQuery,
    PaginatedArtistsError,
    undefined,
    {},
    PaginatedArtistsQueryParams,
    {}
  >({
    url: "/api/Library/artists/paginated",
    method: "get",
    ...variables,
    signal,
  });

export function paginatedArtistsQuery(variables: PaginatedArtistsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (
    options: QueryFnOptions,
  ) => Promise<Schemas.SimpleArtistDtoPaginatedQuery>;
};

export function paginatedArtistsQuery(
  variables: PaginatedArtistsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((
        options: QueryFnOptions,
      ) => Promise<Schemas.SimpleArtistDtoPaginatedQuery>)
    | reactQuery.SkipToken;
};

export function paginatedArtistsQuery(
  variables: PaginatedArtistsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Library/artists/paginated",
      operationId: "paginatedArtists",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchPaginatedArtists(variables, signal),
  };
}

export const useSuspensePaginatedArtists = <
  TData = Schemas.SimpleArtistDtoPaginatedQuery,
>(
  variables: PaginatedArtistsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SimpleArtistDtoPaginatedQuery,
      PaginatedArtistsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    Schemas.SimpleArtistDtoPaginatedQuery,
    PaginatedArtistsError,
    TData
  >({
    ...paginatedArtistsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const usePaginatedArtists = <
  TData = Schemas.SimpleArtistDtoPaginatedQuery,
>(
  variables: PaginatedArtistsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      Schemas.SimpleArtistDtoPaginatedQuery,
      PaginatedArtistsError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    Schemas.SimpleArtistDtoPaginatedQuery,
    PaginatedArtistsError,
    TData
  >({
    ...paginatedArtistsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type AlbumPathParams = {
  /**
   * @format uuid
   */
  albumId: string;
};

export type AlbumError = Fetcher.ErrorWrapper<undefined>;

export type AlbumVariables = {
  pathParams: AlbumPathParams;
} & Context["fetcherOptions"];

export const fetchAlbum = (variables: AlbumVariables, signal?: AbortSignal) =>
  fetch<Schemas.AlbumDto, AlbumError, undefined, {}, {}, AlbumPathParams>({
    url: "/api/Library/albums/{albumId}",
    method: "get",
    ...variables,
    signal,
  });

export function albumQuery(variables: AlbumVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.AlbumDto>;
};

export function albumQuery(variables: AlbumVariables | reactQuery.SkipToken): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.AlbumDto>)
    | reactQuery.SkipToken;
};

export function albumQuery(variables: AlbumVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Library/albums/{albumId}",
      operationId: "album",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchAlbum(variables, signal),
  };
}

export const useSuspenseAlbum = <TData = Schemas.AlbumDto,>(
  variables: AlbumVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.AlbumDto, AlbumError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<Schemas.AlbumDto, AlbumError, TData>({
    ...albumQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useAlbum = <TData = Schemas.AlbumDto,>(
  variables: AlbumVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.AlbumDto, AlbumError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<Schemas.AlbumDto, AlbumError, TData>({
    ...albumQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type ArtistPathParams = {
  /**
   * @format uuid
   */
  artistId: string;
};

export type ArtistError = Fetcher.ErrorWrapper<undefined>;

export type ArtistVariables = {
  pathParams: ArtistPathParams;
} & Context["fetcherOptions"];

export const fetchArtist = (variables: ArtistVariables, signal?: AbortSignal) =>
  fetch<Schemas.ArtistDto, ArtistError, undefined, {}, {}, ArtistPathParams>({
    url: "/api/Library/artists/{artistId}",
    method: "get",
    ...variables,
    signal,
  });

export function artistQuery(variables: ArtistVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<Schemas.ArtistDto>;
};

export function artistQuery(
  variables: ArtistVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<Schemas.ArtistDto>)
    | reactQuery.SkipToken;
};

export function artistQuery(variables: ArtistVariables | reactQuery.SkipToken) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Library/artists/{artistId}",
      operationId: "artist",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchArtist(variables, signal),
  };
}

export const useSuspenseArtist = <TData = Schemas.ArtistDto,>(
  variables: ArtistVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.ArtistDto, ArtistError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<Schemas.ArtistDto, ArtistError, TData>({
    ...artistQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useArtist = <TData = Schemas.ArtistDto,>(
  variables: ArtistVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<Schemas.ArtistDto, ArtistError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<Schemas.ArtistDto, ArtistError, TData>({
    ...artistQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type DirectoriesInPathQueryParams = {
  path?: string;
};

export type DirectoriesInPathError = Fetcher.ErrorWrapper<undefined>;

export type DirectoriesInPathResponse = string[];

export type DirectoriesInPathVariables = {
  queryParams?: DirectoriesInPathQueryParams;
} & Context["fetcherOptions"];

export const fetchDirectoriesInPath = (
  variables: DirectoriesInPathVariables,
  signal?: AbortSignal,
) =>
  fetch<
    DirectoriesInPathResponse,
    DirectoriesInPathError,
    undefined,
    {},
    DirectoriesInPathQueryParams,
    {}
  >({
    url: "/api/Onboarding/listDirectories",
    method: "get",
    ...variables,
    signal,
  });

export function directoriesInPathQuery(variables: DirectoriesInPathVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<DirectoriesInPathResponse>;
};

export function directoriesInPathQuery(
  variables: DirectoriesInPathVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<DirectoriesInPathResponse>)
    | reactQuery.SkipToken;
};

export function directoriesInPathQuery(
  variables: DirectoriesInPathVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Onboarding/listDirectories",
      operationId: "directoriesInPath",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchDirectoriesInPath(variables, signal),
  };
}

export const useSuspenseDirectoriesInPath = <
  TData = DirectoriesInPathResponse,
>(
  variables: DirectoriesInPathVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      DirectoriesInPathResponse,
      DirectoriesInPathError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    DirectoriesInPathResponse,
    DirectoriesInPathError,
    TData
  >({
    ...directoriesInPathQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useDirectoriesInPath = <TData = DirectoriesInPathResponse,>(
  variables: DirectoriesInPathVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      DirectoriesInPathResponse,
      DirectoriesInPathError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    DirectoriesInPathResponse,
    DirectoriesInPathError,
    TData
  >({
    ...directoriesInPathQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type MusicLibrariesError = Fetcher.ErrorWrapper<undefined>;

export type MusicLibrariesResponse = Schemas.MusicLibraryDto[];

export type MusicLibrariesVariables = Context["fetcherOptions"];

export const fetchMusicLibraries = (
  variables: MusicLibrariesVariables,
  signal?: AbortSignal,
) =>
  fetch<MusicLibrariesResponse, MusicLibrariesError, undefined, {}, {}, {}>({
    url: "/api/Onboarding/musicLibraries",
    method: "get",
    ...variables,
    signal,
  });

export function musicLibrariesQuery(variables: MusicLibrariesVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<MusicLibrariesResponse>;
};

export function musicLibrariesQuery(
  variables: MusicLibrariesVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<MusicLibrariesResponse>)
    | reactQuery.SkipToken;
};

export function musicLibrariesQuery(
  variables: MusicLibrariesVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Onboarding/musicLibraries",
      operationId: "musicLibraries",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchMusicLibraries(variables, signal),
  };
}

export const useSuspenseMusicLibraries = <TData = MusicLibrariesResponse,>(
  variables: MusicLibrariesVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<
      MusicLibrariesResponse,
      MusicLibrariesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<
    MusicLibrariesResponse,
    MusicLibrariesError,
    TData
  >({
    ...musicLibrariesQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useMusicLibraries = <TData = MusicLibrariesResponse,>(
  variables: MusicLibrariesVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<
      MusicLibrariesResponse,
      MusicLibrariesError,
      TData
    >,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<
    MusicLibrariesResponse,
    MusicLibrariesError,
    TData
  >({
    ...musicLibrariesQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type RegisterMusicLibraryQueryParams = {
  path?: string;
};

export type RegisterMusicLibraryError = Fetcher.ErrorWrapper<undefined>;

export type RegisterMusicLibraryVariables = {
  queryParams?: RegisterMusicLibraryQueryParams;
} & Context["fetcherOptions"];

export const fetchRegisterMusicLibrary = (
  variables: RegisterMusicLibraryVariables,
  signal?: AbortSignal,
) =>
  fetch<
    Schemas.MusicLibrary,
    RegisterMusicLibraryError,
    undefined,
    {},
    RegisterMusicLibraryQueryParams,
    {}
  >({ url: "/api/Onboarding/register", method: "post", ...variables, signal });

export const useRegisterMusicLibrary = (
  options?: Omit<
    reactQuery.UseMutationOptions<
      Schemas.MusicLibrary,
      RegisterMusicLibraryError,
      RegisterMusicLibraryVariables
    >,
    "mutationFn"
  >,
) => {
  const { fetcherOptions } = useContext();
  return reactQuery.useMutation<
    Schemas.MusicLibrary,
    RegisterMusicLibraryError,
    RegisterMusicLibraryVariables
  >({
    mutationFn: (variables: RegisterMusicLibraryVariables) =>
      fetchRegisterMusicLibrary(deepMerge(fetcherOptions, variables)),
    ...options,
  });
};

export type LoadAllPluginsError = Fetcher.ErrorWrapper<undefined>;

export type LoadAllPluginsVariables = Context["fetcherOptions"];

export const fetchLoadAllPlugins = (
  variables: LoadAllPluginsVariables,
  signal?: AbortSignal,
) =>
  fetch<undefined, LoadAllPluginsError, undefined, {}, {}, {}>({
    url: "/api/Plugin/load",
    method: "get",
    ...variables,
    signal,
  });

export function loadAllPluginsQuery(variables: LoadAllPluginsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function loadAllPluginsQuery(
  variables: LoadAllPluginsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function loadAllPluginsQuery(
  variables: LoadAllPluginsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Plugin/load",
      operationId: "loadAllPlugins",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) =>
            fetchLoadAllPlugins(variables, signal),
  };
}

export const useSuspenseLoadAllPlugins = <TData = undefined,>(
  variables: LoadAllPluginsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, LoadAllPluginsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<undefined, LoadAllPluginsError, TData>({
    ...loadAllPluginsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useLoadAllPlugins = <TData = undefined,>(
  variables: LoadAllPluginsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, LoadAllPluginsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<undefined, LoadAllPluginsError, TData>({
    ...loadAllPluginsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type UnloadPluginsError = Fetcher.ErrorWrapper<undefined>;

export type UnloadPluginsVariables = Context["fetcherOptions"];

export const fetchUnloadPlugins = (
  variables: UnloadPluginsVariables,
  signal?: AbortSignal,
) =>
  fetch<undefined, UnloadPluginsError, undefined, {}, {}, {}>({
    url: "/api/Plugin/unload",
    method: "get",
    ...variables,
    signal,
  });

export function unloadPluginsQuery(variables: UnloadPluginsVariables): {
  queryKey: reactQuery.QueryKey;
  queryFn: (options: QueryFnOptions) => Promise<undefined>;
};

export function unloadPluginsQuery(
  variables: UnloadPluginsVariables | reactQuery.SkipToken,
): {
  queryKey: reactQuery.QueryKey;
  queryFn:
    | ((options: QueryFnOptions) => Promise<undefined>)
    | reactQuery.SkipToken;
};

export function unloadPluginsQuery(
  variables: UnloadPluginsVariables | reactQuery.SkipToken,
) {
  return {
    queryKey: queryKeyFn({
      path: "/api/Plugin/unload",
      operationId: "unloadPlugins",
      variables,
    }),
    queryFn:
      variables === reactQuery.skipToken
        ? reactQuery.skipToken
        : ({ signal }: QueryFnOptions) => fetchUnloadPlugins(variables, signal),
  };
}

export const useSuspenseUnloadPlugins = <TData = undefined,>(
  variables: UnloadPluginsVariables,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, UnloadPluginsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useSuspenseQuery<undefined, UnloadPluginsError, TData>({
    ...unloadPluginsQuery(deepMerge(fetcherOptions, variables)),
    ...options,
    ...queryOptions,
  });
};

export const useUnloadPlugins = <TData = undefined,>(
  variables: UnloadPluginsVariables | reactQuery.SkipToken,
  options?: Omit<
    reactQuery.UseQueryOptions<undefined, UnloadPluginsError, TData>,
    "queryKey" | "queryFn" | "initialData"
  >,
) => {
  const { queryOptions, fetcherOptions } = useContext(options);
  return reactQuery.useQuery<undefined, UnloadPluginsError, TData>({
    ...unloadPluginsQuery(
      variables === reactQuery.skipToken
        ? variables
        : deepMerge(fetcherOptions, variables),
    ),
    ...options,
    ...queryOptions,
  });
};

export type QueryOperation =
  | {
      path: "/api/Artwork/{artworkId}";
      operationId: "artworkFromId";
      variables: ArtworkFromIdVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Library/search";
      operationId: "search";
      variables: SearchVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Library/tracks/{trackId}/logPlayback";
      operationId: "logPlayback";
      variables: LogPlaybackVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Library/tracks/{trackId}/original";
      operationId: "fileFromLibrary";
      variables: FileFromLibraryVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Library/tracks/{trackId}/transcode";
      operationId: "transcodeTrack";
      variables: TranscodeTrackVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Library/tracks/{trackId}/stream";
      operationId: "streamTrack";
      variables: StreamTrackVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Library/tracks";
      operationId: "tracks";
      variables: TracksVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Library/albums";
      operationId: "albums";
      variables: AlbumsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Library/albums/paginated";
      operationId: "paginatedAlbums";
      variables: PaginatedAlbumsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Library/artists/paginated";
      operationId: "paginatedArtists";
      variables: PaginatedArtistsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Library/albums/{albumId}";
      operationId: "album";
      variables: AlbumVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Library/artists/{artistId}";
      operationId: "artist";
      variables: ArtistVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Onboarding/listDirectories";
      operationId: "directoriesInPath";
      variables: DirectoriesInPathVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Onboarding/musicLibraries";
      operationId: "musicLibraries";
      variables: MusicLibrariesVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Plugin/load";
      operationId: "loadAllPlugins";
      variables: LoadAllPluginsVariables | reactQuery.SkipToken;
    }
  | {
      path: "/api/Plugin/unload";
      operationId: "unloadPlugins";
      variables: UnloadPluginsVariables | reactQuery.SkipToken;
    };
